[ { "title": "Caesar cipher in Java", "url": "/caesar-cipher-in-java/", "categories": "", "tags": "algorithms, java, security", "date": "2017-07-21 22:00:00 +0200", "snippet": "One of the simplest cryptographic algorithms is Caesar cipher. Although itis not secure at all, it shows how basic synchronous ciphers work.IntroThe cipher method is named after Julius Caesar, who ...", "content": "One of the simplest cryptographic algorithms is Caesar cipher. Although itis not secure at all, it shows how basic synchronous ciphers work.IntroThe cipher method is named after Julius Caesar, who presumably have used it toencrypt his military messages (see the history section atWikipedia). Maybe at that time itwas the state of the art. Anyway, the algorithm is good to knowin case you happen to find yourself in the middle of war against the RomanEmpire and will need to decrypt their messages to win the war! :wink:The AlgorithmThe steps of the the Caesar cipher algorithm are as follows: Take each character of given message. Replace the char with the one on position distant by given number ofchars. If the position is outside the alphabet, we are looking for theposition from the beginning of the alphabet, thus creating the loop: a, b,…, y, z, a, b, …, y, z, … If we want to decipher the message we just need to rotate the encryptedmessage by the same number of chars, but into the opposite direction.Just look at the unit tests and it will be clear how it works.So, the cipher takes as an input two parameters: The message to encrypt. The size of the rotation.public String cipher(String message, int rotateBy) { // rotate by only the size of the alphabet: rotateBy %= ALPHABET_SIZE; char[] chars = message.toCharArray(); rotate(chars, rotateBy); return new String(chars);}Message traversalThe first step is to go through all chars in the message and substitute itwith its rotated counterpart. In our case we want to rotate only the alphabetcharacters. The thing here is ASCII codes for lower case chars and upper casechars are in different numeric ranges. Therefore we have to check the limitsof the two alphabets - lower and upper case.private void rotate(char[] chars, int rotateBy) { for (int i = 0; i &lt; chars.length; ++i) { if (isLowerCase(chars[i])) { chars[i] = rotateChar(chars[i], rotateBy, 'a', 'z'); } else if (isUpperCase(chars[i])) { chars[i] = rotateChar(chars[i], rotateBy, 'A', 'Z'); } }}The rotate char functionThe key function in the Caesar’s cipher is the rotation function, which willrotate a single character by given number of chars. Keep in mind that thenumber may be positive or negative, so we can go off the alphabet in bothdirections. When we go off the alphabet, we just create a loop and find thecorrect char from the opposite side by moving by the alphabet size (do youknow why it works?):private char rotateChar(char c, int rotateBy, char firstChar, char lastChar) { c += rotateBy; // check lower bounds for left rotation: if (c &lt; firstChar) { return (char) (c + ALPHABET_SIZE); } // check upper bounds for right rotation: if (c &gt; lastChar) { return (char) (c - ALPHABET_SIZE); } // this one is within alphabet bounds: return c;}Complete Caesar cipher in JavaHere’s the complete Caesar cipher in Java, ready to encrypt your emails orJulius Caesar’s military messages! ;-)package com.farenda.tutorials.algorithms.strings;import java.util.Scanner;import static java.lang.Character.isLowerCase;import static java.lang.Character.isUpperCase;public class CaesarCipher { private static final int ALPHABET_SIZE = 26; public String cipher(String message, int rotateBy) { // rotate by only the size of the alphabet: rotateBy %= ALPHABET_SIZE; char[] chars = message.toCharArray(); rotate(chars, rotateBy); return new String(chars); } private void rotate(char[] chars, int rotateBy) { for (int i = 0; i &lt; chars.length; ++i) { if (isLowerCase(chars[i])) { chars[i] = rotateChar(chars[i], rotateBy, 'a', 'z'); } else if (isUpperCase(chars[i])) { chars[i] = rotateChar(chars[i], rotateBy, 'A', 'Z'); } } } private char rotateChar(char c, int rotateBy, char firstChar, char lastChar) { c += rotateBy; if (c &lt; firstChar) { return (char) (c + ALPHABET_SIZE); } if (c &gt; lastChar) { return (char) (c - ALPHABET_SIZE); } return c; }}Unit testsAs always, the best way to verify is to write some tests:package com.farenda.tutorials.algorithms.strings;import org.junit.Test;import static org.junit.Assert.*;public class CaesarCipherTest { private CaesarCipher caesar = new CaesarCipher(); @Test public void shouldDoNothingWithEmptyString() { assertEquals(\"\", caesar.cipher(\"\", 3)); } @Test public void shouldNotCipherSymbols() { assertEquals(\"-\", caesar.cipher(\"-\", 3)); String symbols = \"1!@#$%^&amp;*(){}/\"; assertEquals(symbols, caesar.cipher(symbols, 3)); } @Test public void shouldCipherLowerCaseLetter() { assertEquals(\"a\", caesar.cipher(\"a\", 0)); assertEquals(\"b\", caesar.cipher(\"a\", 1)); assertEquals(\"d\", caesar.cipher(\"a\", 3)); assertEquals(\"j\", caesar.cipher(\"e\", 5)); assertEquals(\"a\", caesar.cipher(\"z\", 1)); assertEquals(\"c\", caesar.cipher(\"x\", 5)); } @Test public void shouldCipherUpperCaseLetter() { assertEquals(\"A\", caesar.cipher(\"A\", 0)); assertEquals(\"B\", caesar.cipher(\"A\", 1)); assertEquals(\"D\", caesar.cipher(\"A\", 3)); assertEquals(\"J\", caesar.cipher(\"E\", 5)); assertEquals(\"A\", caesar.cipher(\"Z\", 1)); assertEquals(\"C\", caesar.cipher(\"X\", 5)); assertEquals(\"Z\", caesar.cipher(\"C\", -3)); } @Test public void shouldCipherWholeAlphabet() { String allChars = \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\"; assertEquals(\"QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD\", caesar.cipher(allChars, -3)); } @Test public void shouldCycle() { assertEquals(\"aoeu-snth\", caesar.cipher(\"aoeu-snth\", 52)); assertEquals(\"cqgw-upvj\", caesar.cipher(\"aoeu-snth\", 54)); } @Test public void shouldDecipher() { String s = \"aoeu\"; String encrypted = caesar.cipher(s, 2); assertEquals(s, caesar.cipher(encrypted, -2)); }}References Algorithms and Data Structures Tutorial" }, { "title": "Fisher-Yates Shuffle Algorithm", "url": "/fisher-yates-shuffle-algorithm/", "categories": "", "tags": "algorithms, java", "date": "2017-04-22 18:16:00 +0200", "snippet": "Shuffling of collection of items sounds like a trivial task, but in realitythere are subtle traps. In this post we’re going to learn how to shuffle thingsusing unbiased Fisher-Yates Shuffle Algorit...", "content": "Shuffling of collection of items sounds like a trivial task, but in realitythere are subtle traps. In this post we’re going to learn how to shuffle thingsusing unbiased Fisher-Yates Shuffle Algorithm and how to do that indifferent languages.Shuffling trapsThere are some things to be aware when implementing/choosing a shuffling algorithm: Use good Pseudo-Random Number Generator, one that uniformly distributesrandom numbers; Shuffling algorithm should produce each permutation with equal probability;That’s why correct range for random numbers is important. Taking wrong rangemay produce biased results, which is illustrated nicely at Data Genetics(see the Monte Carlo simulation at the bottom).Fisher-Yates ShuffleThe most known and optimal shuffling algorithm is Fisher-Yates shuffle. The algorithm is very easy to implement and produces unbiased results. It hasbeen modernized by Durstenfeld and popularized by Donald Knuth in The Art ofComputer Programming TV series. The Durstenfeld’s implementation of thealgorithm is extremely simple and boils down to just a few lines of code. What’simportant, it runs in linear time O(n) and works in place:// T[] data, Random randfor (int i = data.length-1; i &gt; 0; --i) { swap(data, i, rand.nextInt(i+1));}How Durstenfeld implementation works Go from the end of the list (you can process in the oposite directionby just changing directions in all the steps). Pick random number between 0 and the current position (both inclusive). Exchange the current item with the random one.Complete Java exampleimport java.util.Arrays;import java.util.List;import java.util.Random;import static java.util.Collections.swap;public class RandomSort { public static void main(String[] args) { // Data to sort is a list of 1-char Strings: List&lt;String&gt; items = Arrays.asList(\"HelloShuffleWorld!\".split(\"\")); System.out.println(\"Before shuffle: \" + items); shuffle(items, new Random()); System.out.println(\"Shuffled: \" + items); } private static &lt;T&gt; void shuffle(List&lt;T&gt; items, Random rand) { // going from the last item to the second for (int i = items.size() - 1; i &gt; 0; --i) { // swap the current item with random from 0 to the current (inclusive) swap(items, i, rand.nextInt(i + 1)); } }}To swap elements of the array we just reuse Collections.swap(List, i, j). Ifyou happen to know why there is no swap() method in java.util.Arrays, pleaselet me know in the comments! This is just incredible.The above code produces shuffled output:Before shuffle: [H, e, l, l, o, S, h, u, f, f, l, e, W, o, r, l, d, !]Shuffled: [r, W, l, l, h, o, f, d, e, l, e, f, H, o, !, u, S, l]Now, you are ready to implement card shuffling in you games. :-)Shuffling in JVM worldIn Java and other JVM-based languages, the shuffling can be done using twomethods from java.util.Collections class: shuffle(List) shuffle(List, Random)The shuffle(List) just calls the other method with new Random() as therandomness source, therefore both use exactly the same algorithm. Thisimplementation works in basically the same way, just with optimizations forswapping elements adjusted for types of the list.The usage is straightforward:import java.util.Arrays;import java.util.Collections;import java.util.List;import java.util.Random;public class CollectionsShuffle { public static void main(String[] args) { List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5); System.out.println(\"Numbers: \" + numbers); Collections.shuffle(numbers); System.out.println(\"Shuffled: \" + numbers); Collections.shuffle(numbers); System.out.println(\"Shuffled again: \" + numbers); Collections.shuffle(numbers, new Random()); System.out.println(\"Shuffled with Random: \" + numbers); }}To shuffle an array just convert it to list using Arrays.asList() (orArrays.stream(arr).boxed().toList() or whatever method works for you) and thencall Collections.shuffle(List) as in the example.The above code produces the following output:Numbers: [1, 2, 3, 4, 5]Shuffled: [1, 3, 4, 5, 2]Shuffled again: [2, 1, 3, 5, 4]Shuffled with Random: [1, 2, 4, 3, 5]References Fisher-Yates shuffle in Wikipedia Biased and unbiased shuffling visualization at DataGenetics" }, { "title": "Calculating MD5 hash", "url": "/calculating-md5/", "categories": "", "tags": "java, security", "date": "2017-04-21 12:30:00 +0200", "snippet": "MD5 is a popular cryptographic algorithm used for sign messages, aschecksum, and various other cases. In this post we’re going to show a fewapproaches to calculate it, especially in JVM land.MD5 (M...", "content": "MD5 is a popular cryptographic algorithm used for sign messages, aschecksum, and various other cases. In this post we’re going to show a fewapproaches to calculate it, especially in JVM land.MD5 (Message Digest 5) algorithm should not be used for serious cryptography,because it’s insecure and can be broken very fast using even commodityhardware. Nevertheless, you may encounter it in various systems used fordifferent purposes, therefore it’s good to know how to work with it. So, let’sstart!MD5 Hash in JavaMD5 hash sum is usually represented as a sequence of 32 hex digits. Tocalculate MD5 in JVM languages we can use java.security.MessageDigest classthat provides different Message Digest algorithms. One of them isMD5. Let’s calculate the hash of Hello World string:package com.farenda.java.security;import java.math.BigInteger;import java.nio.charset.Charset;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import static java.nio.charset.StandardCharsets.UTF_8;public class SecurityPlayground { public static void main(String[] args) throws NoSuchAlgorithmException { String data = \"Hello World\"; System.out.printf(\"MD5 of '%s': %s%n\", data, md5(data)); } private static String md5(String data) throws NoSuchAlgorithmException { // Get the algorithm: MessageDigest md5 = MessageDigest.getInstance(\"MD5\"); // Calculate Message Digest as bytes: byte[] digest = md5.digest(data.getBytes(UTF_8)); // Convert to 32-char long String: return String.format(\"%032x%n\", new BigInteger(1, digest)); }}The most tricky part is the conversion from the digest bytes into 32 charslong string. We just create very big number from the bytes and then format it into32 chars long String, with zero padding in case of smaller result (to alwayshave 32 chars.)The code prints the following MD5 hash:MD5 of 'Hello World': b10a8db164e0754105b7a99be72e3fe5MD5 hash using GuavaAnother, even simpler, approach to calculating MD5 hash is to use Hashingclass from Google Guava library. The library is often used in Java projects,so most probably it’s also available in yours.import com.google.common.hash.Hashing;//... rest of the code is like the aboveprivate static String guavaMd5(String data) { return Hashing.md5().hashString(data, UTF_8).toString();}public static void main(String[] args) throws NoSuchAlgorithmException { String data = \"Hello World\"; System.out.printf(\"MD5 in Guava of '%s': %s%n\", data, guavaMd5(data));}When we execute this code it will print the following text:MD5 in Guava of 'Hello World': b10a8db164e0754105b7a99be72e3fe5So the MD5 hash is the same as in pure Java version.Calculate using md5sum commandSometimes we just need to verify the MD5 hash. This can be easily done usingmd5sum command available in many systems, especially in Linux.To compare the hashes calculated above, we can just call the command like this:echo -n \"Hello World\" | md5sumWe’ve used -n option to not include the new line character, automatically addedby echo. This is very important as the extra new line would change thecalculation. And here’s the result:b10a8db164e0754105b7a99be72e3fe5 -This confirms that our programs calculated MD5 as expected.References MD5 at Wikipedia" }, { "title": "Parallel Merge Sort in Java", "url": "/parallel-merge-sort-in-java/", "categories": "", "tags": "algorithms, java", "date": "2017-03-30 19:40:00 +0200", "snippet": "Divide and Conquer algorithms are great subject for parallelism. Here we present Parallel Merge Sort implemented using Java ForkJoin Framework.Parallel sort stepsParallel Merge Sort consists of the...", "content": "Divide and Conquer algorithms are great subject for parallelism. Here we present Parallel Merge Sort implemented using Java ForkJoin Framework.Parallel sort stepsParallel Merge Sort consists of the same steps as other tasks executed inForkJoin Pool, namely: If the task is small enough - do it directly.In case of Merge Sortwe can decide that when a subarray to sort is smaller than some value (wename it SORT_THRESHOLD), then we’ll use InsertionSort, which willsort it in-place. Else do Merge Sort of both parts as separate tasks, executed in a ForkJoinPool. This will allow us to sort parts of an array independently and thenjust merge them.MergSort as RecursiveActionThe implementation consists of a few key points we need to do: extend RecursiveAction to allow execution in ForkJoin Pool decide when to sort directly execute parallel tasks for subarrays merge everything at the end.Therefore the heart of the Parallel Merge Sort with Fork Join Framework lookslike this:import java.util.concurrent.RecursiveAction;public class ParallelMergeSort extends RecursiveAction { // Decides when to fork or compute directly: private static final int SORT_THRESHOLD = 128; // Defines subarray to sort: public ParallelMergeSort(int[] values, int from, int to) @Override protected void compute() { if (from &lt; to) { int size = to - from; if (size &lt; SORT_THRESHOLD) { // Sort in-place using Insertion Sort: insertionSort(); } else { int mid = from + Math.floorDiv(size, 2); // Do MergeSort in parallel on subarrays. // This will submit the tasks to the current // ForkJoin Pool: invokeAll( new ParallelMergeSort(values, from, mid), new ParallelMergeSort(values, mid + 1, to)); // Merge sorted subarrays: merge(mid); } } } // ...}Complete Parallel Merge SorterThis is complete implementation of Parallel Merge Sort using Fork-JoinFramework to do parallel execution:import java.util.Arrays;import java.util.concurrent.RecursiveAction;public class ParallelMergeSort extends RecursiveAction { // Decides when to fork or compute directly: private static final int SORT_THRESHOLD = 128; private final int[] values; private final int from; private final int to; public ParallelMergeSort(int[] values) { this(values, 0, values.length-1); } public ParallelMergeSort(int[] values, int from, int to) { this.values = values; this.from = from; this.to = to; } public void sort() { compute(); } @Override protected void compute() { if (from &lt; to) { int size = to - from; if (size &lt; SORT_THRESHOLD) { insertionSort(); } else { int mid = from + Math.floorDiv(size, 2); invokeAll( new ParallelMergeSort(values, from, mid), new ParallelMergeSort(values, mid + 1, to)); merge(mid); } } } private void insertionSort() { for (int i = from+1; i &lt;= to; ++i) { int current = values[i]; int j = i-1; while (from &lt;= j &amp;&amp; current &lt; values[j]) { values[j+1] = values[j--]; } values[j+1] = current; } } private void merge(int mid) { int[] left = Arrays.copyOfRange(values, from, mid+1); int[] right = Arrays.copyOfRange(values, mid+1, to+1); int f = from; int li = 0, ri = 0; while (li &lt; left.length &amp;&amp; ri &lt; right.length) { if (left[li] &lt;= right[ri]) { values[f++] = left[li++]; } else { values[f++] = right[ri++]; } } while (li &lt; left.length) { values[f++] = left[li++]; } while (ri &lt; right.length) { values[f++] = right[ri++]; } }}Test and performance comparisonAs usually we need to check somehow that it works. :wink: But for brevity we’llshow only JUnit test for substantialamount of data (100 millions) and we’ll do that for both MergeSort and Parallel MergeSort:import org.junit.Test;import java.util.Arrays;import java.util.Random;import static org.junit.Assert.assertArrayEquals;public class ParallelMergeSortTest { //... other tests cut for brevity @Test public void performanceTest() { int[] serial = new Random().ints(100_000_000).toArray(); int[] parallel = Arrays.copyOf(serial, serial.length); MergeSort mergeSort = new MergeSort(); long start = System.currentTimeMillis(); mergeSort.sort(serial); System.out.println(\"Merge Sort done in: \" + (System.currentTimeMillis()-start)); ParallelMergeSort sorter = new ParallelMergeSort(parallel); start = System.currentTimeMillis(); sorter.sort(); System.out.println(\"Parallel Merge Sort done in: \" + (System.currentTimeMillis()-start)); assertArrayEquals(parallel, serial); }}I run that a few times on my laptop with 2 cores and the results were around this:Merge Sort done in: 31077Parallel Merge Sort done in: 20020Clearly Parallel Merge Sort is much faster for arrays of 100M of elements. Thespeedup is not 2x, because there are overheads for scheduling tasks in pool, butstill the difference is substantial.Both sorting algorithms use InsertionSort when subarray tosort is below defined threshold. I found value 128 to give pretty goodresults in my environment - maybe there is a better value around, but, in mycase, it gave better results than values 64, 256, 512, 768, 1024, etc.References See details of Insertion Sort See detailed explanation of Merge Sort ForkJoin explained Check out other algorithms in Algorithms section" }, { "title": "Clojure transients - fast mutations in persistent world", "url": "/clojure-transients-fast-mutations-in-persistent-world/", "categories": "", "tags": "clojure", "date": "2016-12-21 06:01:00 +0100", "snippet": "Clojure transients is a nice way to optimize performance of sensitive codewithout leaving familiar Clojure world. In this post we show how to use them toboost performance.Basic flow with transients...", "content": "Clojure transients is a nice way to optimize performance of sensitive codewithout leaving familiar Clojure world. In this post we show how to use them toboost performance.Basic flow with transientsThe code structure is the same as in any Clojure code, except turning mutationson using transient function, modifications using bang! versions of functions, and persisting back with persistent! function:(defn transient-flow [v] (let [tv (transient v)] (-&gt; tv ;; mutate with bang! functions persistent!)))Now you can call it like any other Clojure code:(is (= [1 2 3] (transient-flow [1 2 3])))Transient mutation functionsLike their immutable versions transients support read-only operations withstandard functions (count, get, etc.), but for mutations they have their ownversions, which we will cover here.conj! - add elements to a transient collection(defn conj-inline [coll val] (let [tv (transient coll)] (persistent! (conj! tv val))))The test:(is (= [1 2 3 42] (conj-inline [1 2 3] 42)))assoc! - create/replace mapping for a keyHere we just replace each value with its multiplication by n:(defn times [v n] (loop [tv (transient v) i (dec (count v))] (if (&lt;= 0 i) (recur (assoc! tv i (* n (get tv i))) (dec i)) (persistent! tv))))And test:(is (= [2 4 6] (times [1 2 3] 2)))dissoc! - remove mapping for a key(defn remove-key [m key] (-&gt; m transient (dissoc! key) persistent!))Let’s run it:(is (= {:points 1234} (remove-key {:points 1234 :level 4} :level)))pop! - remove last from a vector(defn remove-last [v] (-&gt; v transient pop! persistent!))Pop from stack seems to work:(is (= [1 2] (remove-last [1 2 3])))disj! - remove last from a set(defn remove-from-set [s key] (-&gt; s transient (disj! key) persistent!))The test:(is (= #{1 3} (remove-from-set #{1 2 3} 2)))Transient types - vectors, maps, setsOnly persistent vectors, hash maps, and hash sets can be transient. Whenyou try to turn an unsupported type into a transient then ClassCastExceptionwill be thrown:(defn transient-list [l] (persistent! (transient l)))The test:(deftest should-throw-exception-for-non-transientable-types (try (transient-list (range 10)) (throw (IllegalStateException. \"Should fail!\")) (catch ClassCastException e (prn \"List cannot be transient: \" (.getMessage e)))))Properties of transientsThere are a few things that it’s good to keep in mind when using transients: creating and persisting a transient take O(1) time each they require thread isolation, because they share mutable state between operations.References: How to use transients to implement Insertion Sort Check out other Clojure Articles! The code is available at GitHub" }, { "title": "Insertion Sort in Clojure", "url": "/insertion-sort-in-clojure/", "categories": "", "tags": "clojure, algorithms", "date": "2016-12-18 16:12:00 +0100", "snippet": "Insertion sort in Clojure can be implemented in different ways. In this post wecompare implementations with and without Clojure transients.Unit TestSometimes, after writing a test, it turns out tha...", "content": "Insertion sort in Clojure can be implemented in different ways. In this post wecompare implementations with and without Clojure transients.Unit TestSometimes, after writing a test, it turns out that everything works and there’snothing to implement. So, let’s start with a test and see if that’s the casehere:(ns poligon.algorithms.sorting-test (:require [poligon.algorithms.sorting :refer :all] [clojure.test :refer :all]));; random 10.000 numbers:(def unsorted-data (vec (doall (repeatedly 10000 #(rand-int 10000)))));; expected result:(def sorted-data (sort unsorted-data))(deftest insertion-sort-test (is (= [] (insertion-sort []))) (is (= [1 2 3] (insertion-sort [1 2 3]))) (is (= [1 2 3 4 5] (insertion-sort [5 2 3 4 1]))) ;; transients version: (is (= sorted-data (time (insertion-sort unsorted-data)))) ;; persistent vector version: (is (= sorted-data (time (insertion-sort-simple unsorted-data)))))Insertion sortFirst let’s implement the algorithm. The flow is simple: take next element andinsert into correct position in already sorted vector. In this version we justreorder elements of persistent vector as we usually do in Clojure:(defn- insert-simple [tv idx] (let [current-value (get tv idx)] (loop [i idx v tv] (let [left-value (get v (dec i))] (if (and (pos? i) (&gt; left-value current-value)) (recur (dec i) (assoc v i left-value)) (assoc v i current-value))))))(defn insertion-sort-simple [v] (let [size (-&gt; v count dec)] (loop [i 1 tv v] (if (&lt;= i size) (recur (inc i) (insert-simple tv i)) tv))))After running the tests we can see that this version works. But here we haveoverhead of handling of persistent vector. If we would like to change only a fewvalues it wouldn’t matter much, but we cannot assume that. Insertion sort, asmany other algorithms, may reorder many elements. In such cases we can resort totransients and mutate local data structure.Transients for performanceA nice thing about transients is that the code structure is almost the same aswe normally write in Clojure. So we can develop an algorithm and then introducetransients. The only differences are: Conversion of persistent data structure to transient using transient function. Mutation using bang versions of the functions (assoc!, dissoc!, etc.) Turning transient back into persistent structure using persistent!.In case of insertion sort we only use transient, assoc!, andpersistent!. The rest of the code stays the same:(ns poligon.algorithms.sorting)(defn- insert \"Insert element from `idx` into correct position in transient vector `tv`.\" [tv idx] (let [current-value (get tv idx)] (loop [i idx v tv] (let [left-value (get v (dec i))] (if (and (pos? i) (&gt; left-value current-value)) (recur (dec i) (assoc! v i left-value)) (assoc! v i current-value))))))(defn insertion-sort \"Insertion sort using transients.\" [v] (let [size (-&gt; v count dec)] (loop [i 1 tv (transient v)] (if (&lt;= i size) (recur (inc i) (insert tv i)) (persistent! tv)))))Difference in performanceAfter running the tests a couple of times, the run-times were pretty much thesame as here. The transients version is about 3 times faster:lein test :only poligon.algorithms.sorting-testlein test poligon.algorithms.sorting-test\"Elapsed time: 8855.431509 msecs\"\"Elapsed time: 24010.397826 msecs\"Ran 2 tests containing 6 assertions.0 failures, 0 errors.Of course the numbers way be different for different data. But it’s prettyclear that transients increase performance without complicating code much.References: Insertion Sort explained Check out other cool Clojure articles! The code is available at GitHub" }, { "title": "Quicksort in Java", "url": "/quicksort-in-java/", "categories": "", "tags": "algorithms, java", "date": "2016-12-16 11:40:00 +0100", "snippet": "Quicksort is one of the fastest sorting algorithms. In this article we implementQuicksort in Java, describe how it works and its properties.How Quicksort worksSimilarly to the merge sort,quicksort ...", "content": "Quicksort is one of the fastest sorting algorithms. In this article we implementQuicksort in Java, describe how it works and its properties.How Quicksort worksSimilarly to the merge sort,quicksort belongs to Divide and Conquer group of algorithms. It consists of thefollowing steps: Pick an element that will serve as comparison point - pivot. Partition step - reorders elements in such a way that elements lower thanpivot are on its left side, and greater or equal to pivot are on itsright side. Recursively sort subarrays on both sides of pivot element.Contrary to the merge sort, where real work was done in the merge step, inquicksort the real work is performed in partitioning step. And it is thepartition function that differentiate implementations of quicksort.The algorithm can be also parallelized, because it is a divide and conqueralgorithm. But the pallalelization is worse than in case of merge sort,because the sizes of subarrays are sensitive to the selection of pivotelement.Quicksort Pivot calculation strategies pick the first/last element: easy to implement, but will downgradeperformance, when the data is already sorted (why?) pick an element from the middle pick random element calculate median of three (first, medium, and last): better performance incase of sorted data calculate median of medians.Quicksort propertiesQuicksort has the following properties: worst case performance is O(n^2) (selected pivot doesn’t split much) average case performance is O(n log n) worst case space complexity is O(n) or O(log n) (optimized version) has many implementations (stable and unstable, in-place or not)Quicksort implementationIn the following quicksort implementation we always use the last element ofsubarray as the pivot element:package com.farenda.tutorials.algorithms.sorting;public class QuickSort { public void sort(int[] values) { sort(values, 0, values.length-1); } private void sort(int[] values, int first, int last) { if (first &lt; last) { int pivot = partition(values, first, last); sort(values, first, pivot-1); sort(values, pivot+1, last); } } private int partition(int[] values, int first, int last) { int greater = first; for (int i = first; i &lt; last; ++i) { if (values[i] &lt;= values[last]) { swap(values, i, greater++); } } swap(values, greater, last); return greater; } private void swap(int[] values, int i, int j) { int tmp = values[i]; values[i] = values[j]; values[j] = tmp; }}As an exercise implement pivot selection using the median-of-three strategy(calculate the median of the first, medium, and the last element). This strategyis more resilient to sorted data.References: See other sorting algorithms" }, { "title": "Composed Method Pattern explained", "url": "/composed-method-pattern/", "categories": "", "tags": "software-design, java, clojure", "date": "2016-12-02 22:10:00 +0100", "snippet": "Composed Method Pattern is the most useful and practical pattern I use andat the same time it’s not known to many developers. It’s surprising, because thepattern is the foundation of maintainable c...", "content": "Composed Method Pattern is the most useful and practical pattern I use andat the same time it’s not known to many developers. It’s surprising, because thepattern is the foundation of maintainable code.Almost every code review I do contains the sentence “Refactor this to ComposedMethod”. The Composed Method Pattern is easy and fast to implement, withimmediate benefits.Purpose of Composed MethodYou cannot immediately understand method's logic.In corporate word it’s a standard. There is plenty of low quality code thathave to be maintained, extended, etc. But how to change anything, when thebusiness logic is a total mess? Sounds familiar? Here enters the ComposedMethod and the pattern can be summarized in one sentence:Composed Method literally turns shit into honey.How to introduceApply Extract Method refactoring on logically coherent blocks of code untilall are in separate methods, where names of the methods tell what they do (nothow).Single Level Of Abstraction (SLA Principle)All steps of processing in a method should be at the same level ofabstraction. In other words, they should not expose their details, but movethe details to separate methods that give them intent-revealing names. Theparts of a method should tell what is being done, not how.Composed Method in JavaIn the below code example there’s a method that calculates something. It takesparameters: a scores as a String, numbers of scores in the String, and how manyof them should be taken into account.Bofore Composed Methodprivate int sumBest(String data, int size, int howMany) { Scanner scanner = new Scanner(data); int[] scores = new int[size]; for (int i = 0; i &lt; size; ++i) { scores[i] = scanner.nextInt(); } Arrays.sort(scores); int sum = 0; for (int i = scores.length-howMany; i &lt; scores.length; ++i) { sum += scores[i]; } return sum;}Even though the code is simple, it’s not immediately obvious how it works andwhat it does. You have to dig into details to pick out steps of processing itdoes and remember them for further code analysis - just recall a real businesscode with much longer and more complicated methods.The above method can be called like this:int sum = sumBestBefore(\"1 2 3 4 5 6 7 8 9 10\", 10, 3);System.out.println(\"Sum of best 3: \" + sum);// prints: Sum of best 3: 27Refactored to Composed MethodHere we’ve got the same code, but refactored to Composed Method making eachstep explicit, thus the whole code is much more readable:private int sumBest(String data, int size, int howMany) { int[] scores = loadScores(data, size); sort(scores); return sumLast(scores, howMany);}private int[] loadScores(String data, int size) { Scanner scanner = new Scanner(data); int[] numbers = new int[size]; for (int i = 0; i &lt; size; ++i) { numbers[i] = scanner.nextInt(); } return numbers;}private int sumLast(int[] scores, int howMany) { int sum = 0; for (int i = scores.length-howMany; i &lt; scores.length; ++i) { sum += scores[i]; } return sum;}Now it’s clearly visible that whole processing consists of three steps: Loading scores from given data string. Sorting the scores. Summing the last (biggest) scores.The sumBest() method does whole processing at the single level of abstraction -loads scores, sorts them, and calculates sums. It operates on scores. How itloads them? Who cares!? At this level it’s not important. If someone want’s toknow, they can always go to the loadScores() method.The same with other steps - is it important, for understanding sumBest whatkind of sorting is used? Of course not! It’s just a detail here, so we hid it.Also, note how small and easy to understand the methods are. The details of eachstep can be understand in no time!Composed Method in functional languagesAlthough the Composed Method Pattern is known from Object-OrientedProgramming, it is equally well applicable in Functional Programming. Here wecan name it Composed Function. :-)Before Composed FunctionThe following Clojure version does the same thing as the Java code above. Again,to understand what it does you have to dig into unimportant details:(defn sum-best [data size how-many] (let [scanner (Scanner. data)] (-&gt;&gt; (for [i (range 0 size)] (.nextInt scanner)) (sort (java.util.Collections/reverseOrder)) (take how-many) (apply +))))Refactored to Composed FunctionHere is the same code logic, but with readable, explicit processing steps -Composed Function:(defn load-scores [data size] (let [scanner (Scanner. data)] (for [i (range 0 size)] (.nextInt scanner))))(defn sort-desc [scores] (sort (java.util.Collections/reverseOrder) scores))(defn sum-first [how-many scores] (apply + (take how-many scores)))(defn sum-best [data size how-many] (-&gt;&gt; (load-scores data size) sort-desc (sum-first how-many)))Properties of code refactored to Composed MethodBenefits Makes the code immediately understandableExtracted methods have names that immediately tell what they do (intentrevealing names), without having to analyze ton of code. Helps to find duplicated code. Helps to identify responsibilities. Makes unit testing easy.Drawbacks Creates more small methods.From my experience it is not a problem, because duplicated code is unifiedand methods with other responsibilities are moved to their own or correctclasses. May make the debugging more difficult, because the logic is spread indifferent methods.There is more methods and classes, however they are smaller, easier tounderstand, and reason about.References “Refactoring to Design Patterns” by Joshua Kerievsky" }, { "title": "Clojure REPL docs", "url": "/clojure-repl-docs/", "categories": "", "tags": "clojure", "date": "2016-11-25 16:05:00 +0100", "snippet": "In this post we show how to read docs in Clojure REPL. You’ll learn usefulcommands to find and display Clojure and Java docs, how to display Clojuresource code.Print documentationTo print documenta...", "content": "In this post we show how to read docs in Clojure REPL. You’ll learn usefulcommands to find and display Clojure and Java docs, how to display Clojuresource code.Print documentationTo print documentation of a function, var, namespace, macro,etc. just use the doc macro - (doc var\\_or\\_special\\_form):user&gt; (doc doc)-------------------------clojure.repl/doc([name])Macro Prints documentation for a var or special form given its nameuser&gt; (doc clojure.repl)-------------------------clojure.repl Utilities meant to be used interactively at the REPLFind docs matching patternsTo find any documentation by regexp use (find-doc \"RegExp\"):user&gt; (find-doc \"red.cer\")-------------------------clojure.core.reducers/-&gt;Cat([cnt left right]) Positional factory function for class clojure.core.reducers.Cat.-------------------------clojure.core.reducers/reducer([coll xf]) Given a reducible collection, and a transformation function xf, returns a reducible collection, where any supplied reducing fn will be transformed by xf. xf is a function of reducing fn to reducing fn.-------------------------clojure.core.reducers A library for reduction and parallel folding. Alpha and subject to change. Note that fold and its derivatives require Java 7+ or Java 6 + jsr166y.jar for fork/join support. See Clojure's pom.xml for the dependency info.Display sourceOne of the most useful things - (source symbol):user&gt; (source identity)(defn identity \"Returns its argument.\" {:added \"1.0\" :static true} [x] x)Display JavaDocTo display API docs of Java classes in default browser - (javadoc object-or-class):;; opens JavaDoc for String class in default browseruser&gt; (javadoc String);; The same as above, because `javadoc` will take class;; of the given object and then proceed in the same way:user&gt; (javadoc \"aoeu\")By default it opens remote Oracle’s JDK page for given class/object.However, if you would like to display Javadoc locally you will need to add itslocation:;; Add local doc path if you have:user&gt; (clojure.java.javadoc/add-local-javadoc \"/home/przemek/doc/java/jdk-8-api/api/\")Now (javadoc Thread) will display local page for given class or will fallbackto remote site if it won’t find it locally (usually because a wrong path wasdefined).Clojure REPL helpers in other namespacesWhen you start Clojure REPL and begin within user namespace you willhave the following functions at your disposal: doc, find-doc,source, and javadoc. But when you switch to other namespace and try touse them you will get an exception:myns&gt; (doc clojure.repl/apropos)CompilerException java.lang.RuntimeException: Unable to resolve symbol: doc in this context, compiling:(*cider-repl localhost*:134:16)To fix that you have to import the functions by yourself:myns&gt; (use '[clojure.repl :only (dir doc find-doc source)])myns&gt; (doc clojure.repl/apropos)-------------------------clojure.repl/apropos([str-or-pattern]) Given a regular expression or stringable thing, return a seq of allpublic definitions in all currently-loaded namespaces that match thestr-or-pattern.Inject repl tools automaticallyIf you are using Leiningen then you can inject helper functions automaticallyfrom your ~/.lein/profiles.clj file:{:repl {:injections [(use '[clojure.repl :only [doc find-doc source]])]}}References: Check out other parts of Clojure Tutorial! Clojure reference" }, { "title": "Merge Sort in Java", "url": "/merge-sort-in-java/", "categories": "", "tags": "algorithms, java", "date": "2016-11-11 13:10:00 +0100", "snippet": "In this post we’ll implement Merge Sort in Java. It’s fast, divide and conquer,sorting algorithm that can be also parallelized.How Merge Sort worksThe algorithm belongs to the Divide and Conquer fa...", "content": "In this post we’ll implement Merge Sort in Java. It’s fast, divide and conquer,sorting algorithm that can be also parallelized.How Merge Sort worksThe algorithm belongs to the Divide and Conquer family. This, basically,means that it divides the sorting problem into smaller parts to solve. The coreof the merge sort goes as follows: When the array consists of only one element do nothing, because it is alreadysorted. Find the middle point of array (or mid points when you want to split intomore parts). Recursively merge sort part of array from the start to the middle point. Recursively merge sort part of array above the middle point. Merge (join) both sorted parts.The above algorithm can be simply expressed in Java code:void mergeSort(int[] numbers, int from, int to) { if (from &lt; to) { int mid = from + Math.floorDiv(to-from, 2); mergeSort(numbers, from, mid); mergeSort(numbers, mid+1, to); merge(numbers, from, mid, to); }}Notice that we calculate the mid point using subtraction instead of addition(from + to) / 2, because if both values are big enough they could overflow,which is a common error.Merge Sort propertiesThe notable properties of the merge sort are: it is a stable sort (preserves order of already sorted elements) best/average/worst case performance is O(n log n) memory complexity is O(n) (requires additional memory for n elements) can be parallelized, because parts of array are sorted independentlyMerge Sort implementationKeep in mind that there are a few different ways to implement the algorithm withvarious levels of complexity. The one we present here is more complex than SelectionSort and InsertionSort, but it’s readableand very instructive to learn:package com.farenda.tutorials.algorithms.sorting;import java.util.Arrays;public class MergeSort { public void sort(int[] numbers) { mergeSort(numbers, 0, numbers.length-1); } void mergeSort(int[] numbers, int from, int to) { if (from &lt; to) { int mid = from + Math.floorDiv(to-from, 2); mergeSort(numbers, from, mid); mergeSort(numbers, mid+1, to); merge(numbers, from, mid, to); } } void merge(int[] numbers, int from, int mid, int to) { int[] left = Arrays.copyOfRange(numbers, from, mid+1); int[] right = Arrays.copyOfRange(numbers, mid+1, to+1); int li = 0, ri = 0; while (li &lt;= left.length &amp;&amp; ri &lt; right.length) { if (left[li] &lt; right[ri]) { numbers[from++] = left[li++]; } else { numbers[from++] = right[ri++]; } } while (li &lt; left.length) { numbers[from++] = left[li++]; } while (ri &lt; right.length) { numbers[from++] = right[ri++]; } }}Unit testsHere are some JUnit tests to verify the implementation:package com.farenda.tutorials.algorithms.sorting;import org.junit.Test;import static org.junit.Assert.assertArrayEquals;import static org.junit.Assert.assertEquals;public class MergeSortTest { private MergeSort sorter = new MergeSort(); @Test public void shouldDoNothingWithEmptyArray() { int[] values = {}; sorter.sort(values); assertEquals(values.length, 0); } @Test public void shouldDoNothingWithOneElementArray() { int[] values = {42}; sorter.sort(values); assertArrayEquals(new int[] {42}, values); } @Test public void shouldSortValues() { int[] values = new int[] { 9, -3, 5, 0, 1}; int[] expectedOrder = new int[] { -3, 0, 1, 5, 9}; sorter.sort(values); assertArrayEquals(expectedOrder, values); }}References: Check out other sorting algorithms in Algorithms articles" }, { "title": "Towers of Hanoi recursive version", "url": "/towers-of-hanoi-recursive-version/", "categories": "", "tags": "java, algorithms", "date": "2016-09-20 15:40:00 +0200", "snippet": "Towers of Hanoi is a well known puzzle, very often used to teach recursion. Inthis post we show how to solve the puzzle recursively.The rulesThere are three towers/pegs/rods with a number of disks ...", "content": "Towers of Hanoi is a well known puzzle, very often used to teach recursion. Inthis post we show how to solve the puzzle recursively.The rulesThere are three towers/pegs/rods with a number of disks on one of them. Thedisks are of different sizes, stacked one on another, and the sorted fromsmallest to the biggest (on the bottom). The objective is to move entire stackto another peg, but: only one disk can be moved at a time, only top disks can be moved, disks cannot be put on top of smaller disk.The complexity of the solution is 2^n - 1.Towers as stacksIn this implementation we keep pegs/towers as stacks to simplify handling ofdisks. You can use arrays here, but then you would have to manually track whereyou are on each peg. We use Collections.asLifoQueue() to turn LinkedList into aStack.Also to easily identify each peg we’ve created a helpful enum.enum Peg {A, B, C}private final EnumMap&lt;Peg, Queue&lt;Integer&gt;&gt; pegs = new EnumMap&lt;&gt;(Peg.class);{ // Use lists as Stacks: pegs.put(A, asLifoQueue(new LinkedList&lt;&gt;())); pegs.put(B, asLifoQueue(new LinkedList&lt;&gt;())); pegs.put(C, asLifoQueue(new LinkedList&lt;&gt;()));}Towers initializationThe constructor takes only one parameter - a number of disks. In makes senseonly for non-negative numbers, so we check that and then initialize the firstpeg with disks - smallest on top:public HanoiTowers(int n) { if (n &lt; 0) { throw new IllegalArgumentException( \"Pegs must not be negative. Was: \" + n); } while (n &gt; 0) { // Peg A always starts with all the disks: this.pegs.get(A).add(n--); }}The recursive algorithmThe algorithm is simple and consists of three steps: Move all but one disks form peg A to B. Move the last disk from peg A to C. Move all disks from B to C.Complete exampleRecursive implementationpackage com.farenda.tutorials.algorithms;import java.util.EnumMap;import java.util.LinkedList;import java.util.Queue;import static com.farenda.tutorials.algorithms.HanoiTowers.Peg.*;import static java.util.Collections.asLifoQueue;public class HanoiTowers { enum Peg {A, B, C} private final EnumMap&lt;Peg, Queue&lt;Integer&gt;&gt; pegs = new EnumMap&lt;&gt;(Peg.class); { // Use lists as Stacks: pegs.put(A, asLifoQueue(new LinkedList&lt;&gt;())); pegs.put(B, asLifoQueue(new LinkedList&lt;&gt;())); pegs.put(C, asLifoQueue(new LinkedList&lt;&gt;())); } public HanoiTowers(int n) { if (n &lt; 0) { throw new IllegalArgumentException( \"Pegs must not be negative. Was: \" + n); } while (n &gt; 0) { // Peg A always starts with all the disks: this.pegs.get(A).add(n--); } } // return content of selected peg public Integer[] peg(Peg peg) { Queue&lt;Integer&gt; p = pegs.get(peg); return p.toArray(new Integer[p.size()]); } public void solve(Peg from, Peg to) { solve(pegs.get(from).size(), from, to); } private void solve(int n, Peg from, Peg to) { if (n &gt;= 1) { Peg spare = sparePeg(from, to); solve(n-1, from, spare); move(from, to); solve(n-1, spare, to); } } private Peg sparePeg(Peg from, Peg to) { Peg spare = null; switch (from) { case A: spare = notSelected(to, B, C); break; case B: spare = notSelected(to, A, C); break; case C: spare = notSelected(to, A, B); break; } return spare; } private Peg notSelected(Peg given, Peg a, Peg b) { return (given == a) ? b : a; } private void move(Peg from, Peg to) { pegs.get(to).add(pegs.get(from).remove()); } @Override public String toString() { // helpful for debugging: return pegs.toString(); }}JUnit testspackage com.farenda.tutorials.algorithms;import com.farenda.tutorials.algorithms.HanoiTowers.Peg;import org.junit.Test;import static com.farenda.tutorials.algorithms.HanoiTowers.Peg.*;import static org.junit.Assert.assertArrayEquals;public class HanoiTowersTest { private static final Integer[] EMPTY = {}; private static final Integer[] ONE_DISK = {1}; private static final Integer[] THREE_DISKS = {1, 2, 3}; private static final Integer[] FIVE_DISKS = {1, 2, 3, 4, 5}; private static final Integer[] TWENTY_DISKS = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20}; @Test(expected = IllegalArgumentException.class) public void shouldThrowExceptionForNegativePegs() { new HanoiTowers(-1); } @Test public void shouldInitializePegsWithGivenNumberOfDisks() { HanoiTowers hanoi = new HanoiTowers(0); assertPegs(hanoi, EMPTY, EMPTY, EMPTY); hanoi = new HanoiTowers(1); assertPegs(hanoi, ONE_DISK, EMPTY, EMPTY); hanoi = new HanoiTowers(5); assertPegs(hanoi, FIVE_DISKS, EMPTY, EMPTY); } @Test public void shouldDoNothingWithEmptyPegs() { HanoiTowers hanoi = new HanoiTowers(0); hanoi.solve(A, B); assertPegs(hanoi, EMPTY, EMPTY, EMPTY); } @Test public void shouldMoveTheOnlyDiskToSelectedPeg() { HanoiTowers hanoi = new HanoiTowers(1); hanoi.solve(A, B); assertPegs(hanoi, EMPTY, ONE_DISK, EMPTY); hanoi.solve(B, C); assertPegs(hanoi, EMPTY, EMPTY, ONE_DISK); hanoi.solve(C, A); assertPegs(hanoi, ONE_DISK, EMPTY, EMPTY); } @Test public void shouldMoveAllDisksToSelectedPeg() { HanoiTowers hanoi = new HanoiTowers(3); hanoi.solve(A, C); assertPegs(hanoi, EMPTY, EMPTY, THREE_DISKS); hanoi = new HanoiTowers(5); hanoi.solve(A, C); assertPegs(hanoi, EMPTY, EMPTY, FIVE_DISKS); hanoi = new HanoiTowers(20); hanoi.solve(A, C); assertPegs(hanoi, EMPTY, EMPTY, TWENTY_DISKS); } private void assertPegs(HanoiTowers hanoi, Integer[] pegA, Integer[] pegB, Integer[] pegC) { assertPeg(hanoi, A, pegA); assertPeg(hanoi, B, pegB); assertPeg(hanoi, C, pegC); } private void assertPeg(HanoiTowers hanoi, Peg peg, Integer[] actual) { assertArrayEquals(hanoi.toString(), hanoi.peg(peg), actual); }}References: How to use List as Stack JUnit Tutorial with examples" }, { "title": "Top 10 sites to practice programming", "url": "/top-10-sites-to-practice-programming/", "categories": "", "tags": "algorithms", "date": "2016-09-19 17:20:00 +0200", "snippet": " HackerRank HackerRank is currently my favourite programming site. There is a lot ofexercises and they are split in different categories - Algorithms, Java,Functional programming, Databases...", "content": " HackerRank HackerRank is currently my favourite programming site. There is a lot ofexercises and they are split in different categories - Algorithms, Java,Functional programming, Databases, etc. Everyone will find somethinginteresting. In many cases solutions can be submitted using differentlanguages - solve one in Java and then try the same in a functional language! I really like one thing about this site - they show output (even incorrect) ofsubmissions. This one, small feature helps a lot figuring out what is wrongwith the submitted code. Compare that with terse “Wrong Answer” on othersites. Rosalind This site has a collection of very interesting problems and learningresources. Of course, there is a bunch of pure algorithmic problems, like onother sites, but the most interesting part is their collection ofbioinformatics problems to solve with helpful learning resources. It’s verycool site where one can see how algorithms can be used to solve real worldchallenges! SPOJ - Sphere Online Judge Very known site with plenty of algorithmic problems. SPOJ also allows to usedifferent programming languages, even very esoteric. These days I visit itless often, but it’s still a good site. TopCoder It’s one of the oldest contests sites. At the beginning there were onlyalgorithmic competitions, but with time they’ve added other typecompetitions - software design, testing, graphical design, etc. TopCoder is the only site I know of, where one can earn some money inprogramming contests. We Chall We Chall is not a programming/contest site by itself, but it keeps a globalranking from many security contests sites (often Capture The Flag type). Veryinteresting challenges that require broad IT knowledge. One site which I likebut is not on We Chall is Backdoor - Security platform. 4clojure In Clojure community the site is very well known. It contains (ATM) 156problems ranging in difficulty from easy to hard. By solving them you canlearn quite a lot of nice tricks in Clojure and feel the beauty of thelanguage. Don’t forget to enroll to code golf league! :-) CodeKata Contrary to mosts programming sites that focus around algorithms and such,CodeKata has a list of problems that will exercise you in differentdirections. The katas set goals that will make you think about modeling ofproblem domain, different trade offs, etc. exercism exercism.io is very interesting and unusual site with programming exercisesthat aid in learning a new language. It has at least two things that make thesite exceptional: Command line client for fetching and submitting solutions. Programmers are encouraged to Code Review other solutions. IMHO being ableto see how others have solved the same problem is a great way to learn alanguage. Just try it! :-) Code Fights I discovered Code Fights just recently, but found their approach to the competetive programming quite amusing. In other places you can take your time and solve problems slowly, here the time runs really fast and your competitor is trying to solve the same problems faster than you. It’s like playing coding game! :-) Code Chef A good site with plenty of problems and a lot of tutorials. Project Euler A series of challenging mathematical and programming problems. Geeks for Geeks Problems to solve in C, C++, Java, and Python. Kaggle Data Science (machine learning) problems and competitions. Code Forces Well known site with lots of problems and competitions. Coding Game A nice site where you can improve your skills by coding games in various languages. Python Challenge A fun site to practice Python. CS Academy Programming contests (C++, Java, Python, C#) and tutorials. Hacker Earth Leet Code OJ Code Wars Codility Code eval UVa Online Judge Lint Code CodeStepByStep HPC University Weekly Challenge The book about Competitive ProgrammingRecently I’ve discovered a great book exactly about competitive programming: “Competitive Programming, 3rd Edition” by Steven Halim and Felix Halim.And where do you practice programming? Let us know in the comments!" }, { "title": "Prime numbers - Sieve of Eratosthenes in Java", "url": "/prime-numbers-sieve-of-eratosthenes-in-java/", "categories": "", "tags": "algorithms, java", "date": "2016-09-02 13:40:00 +0200", "snippet": "A prime number is a natural number with only two divisors: 1 and itself. In thispost we’re going to show how to find prime numbers using Sieve ofEratosthenes and explain how it works.How it works ...", "content": "A prime number is a natural number with only two divisors: 1 and itself. In thispost we’re going to show how to find prime numbers using Sieve ofEratosthenes and explain how it works.How it works Create a boolean array for the numbers you want to verify.We create an array with size greater by one to comfortably use index asunderlying number. Initially mark all numbers in the array as primes. Start sieving from the smallest prime number - 2. Mark as non primes all multiplies of the current prime.Notice that we start the sieve from i * i. This is because all numbersbelow have been already sieved. For example, when removing multiplies of 5we can start from 25, because all lower multiplies of 5 have been removedwhen 2 and 3 were processed - 5*2 = 2*5 and 5*3 = 3*5. Repeat with the next prime.We don’t have to look for primes above maxPrime, because of reasoning inpoint 4.void markComplexNumbers(boolean[] primes) { primes[0] = primes[1] = false; int maxPrime = (int) Math.sqrt(primes.length); for (int i = 2; i &lt;= maxPrime; ++i) { if (primes[i]) { // remove all multiplies of this prime: for (int j = i*i; j &lt; primes.length; j += i) { primes[j] = false; } } }}Properties of the Sieve of Eratosthenes time complexity is O(n log log n) memory complexity is O(n+1) works great for small (in mathematical sense ;-) ) prime numbersComplete exampleimport java.util.Arrays;public class Sieve { public static void main(String[] args) { boolean[] primes = findPrimes(101); printPrimes(primes); } public static boolean[] findPrimes(int to) { // +1 to have index and number with the same value: boolean[] primes = new boolean[to+1]; Arrays.fill(primes, true); markComplexNumbers(primes); return primes; } private static void markComplexNumbers(boolean[] primes) { primes[0] = primes[1] = false; int maxPrime = (int) Math.sqrt(primes.length); for (int i = 2; i &lt;= maxPrime; ++i) { if (primes[i]) { // remove all multiplies of this prime: for (int j = i*i; j &lt; primes.length; j += i) { primes[j] = false; } } } } private static void printPrimes(boolean[] primes) { for (int i = 2; i &lt; primes.length; ++i) { if (primes[i]) { System.out.print(i + \", \"); } } }}The above code produces the following output:2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47,53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101," }, { "title": "Spring Circular Reference - BeanCurrentlyInCreationException", "url": "/spring-circular-reference-beancurrentlyincreationexception/", "categories": "", "tags": "java, spring", "date": "2016-08-10 22:01:00 +0200", "snippet": "BeanCurrentlyInCreationException is thrown by Spring Framework when it meetscircular reference while setting up application context. Here we show what isit and how to fix it!Beans with circular ref...", "content": "BeanCurrentlyInCreationException is thrown by Spring Framework when it meetscircular reference while setting up application context. Here we show what isit and how to fix it!Beans with circular referenceBean A with constructor injected Bean BLibrary is a Spring Bean that is using another bean - BookRepository - asa dependency injected through constructor:package com.farenda.spring.tutorial.injection.conflict;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;@Componentpublic class Library { private BookRepository bookRepository; @Autowired public Library(BookRepository bookRepository) { this.bookRepository = bookRepository; } public String findBook(int id) { return bookRepository.titleById(id); } public String name() { return \"Public library #1\"; }}Bean B with constructor injected Bean A - circular referenceBookRepository, for some reason, want’s to have Library injected, alsothrough constructor:package com.farenda.spring.tutorial.injection.conflict;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Repository;import java.util.HashMap;import java.util.Map;@Repositorypublic class BookRepository { private Library library; @Autowired public BookRepository(Library library) { this.library = library; } // It's our local database ;-) private Map&lt;Integer, String&gt; books = new HashMap&lt;&gt;(); { books.put(1, \"Effective Java, 2nd edition\"); books.put(2, \"Java Concurrency in Practice\"); books.put(3, \"Spring in Action\"); } public String titleById(int id) { System.out.println(\"In a library: \" + library.name()); return books.get(id); }}The application runnerThe simplest Spring Boot app to run the code:package com.farenda.spring.tutorial.injection.conflict;import org.springframework.boot.SpringApplication;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScanpublic class InjectionConflict { public static void main(String[] args) { ApplicationContext context = SpringApplication .run(InjectionConflict.class, args); Library library = context.getBean(Library.class); System.out.println(\"Title 2: \" + library.findBook(2)); }}When we run the above code the application will fail during startup withUnsatisfiedDependencyException exception, which is caused by BeanCurrentlyInCreationException:2016-08-09 23:29:01.530 INFO 11796 --- [ main] c.f.s.t.i.conflict.InjectionConflict : Starting InjectionConflict on namek with PID 11796 (/home/przemek/Dropbox/projekty/farenda/java/spring-tutorial/build/classes/main started by przemek in /home/przemek/Dropbox/projekty/farenda/java/spring-tutorial)2016-08-09 23:29:01.535 INFO 11796 --- [ main] c.f.s.t.i.conflict.InjectionConflict : No active profile set, falling back to default profiles: default2016-08-09 23:29:01.612 INFO 11796 --- [ main] s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2eda0940: startup date [Tue Aug 09 23:29:01 CEST 2016]; root of context hierarchy2016-08-09 23:29:02.147 WARN 11796 --- [ main] s.c.a.AnnotationConfigApplicationContext : Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'bookRepository' defined in file [/home/przemek/Dropbox/projekty/farenda/java/spring-tutorial/build/classes/main/com/farenda/spring/tutorial/injection/conflict/BookRepository.class]: Unsatisfied dependency expressed through constructor argument with index 0 of type [com.farenda.spring.tutorial.injection.conflict.Library]: Error creating bean with name 'library' defined in file [/home/przemek/Dropbox/projekty/farenda/java/spring-tutorial/build/classes/main/com/farenda/spring/tutorial/injection/conflict/Library.class]: Unsatisfied dependency expressed through constructor argument with index 0 of type [com.farenda.spring.tutorial.injection.conflict.BookRepository]: Error creating bean with name 'bookRepository': Requested bean is currently in creation: Is there an unresolvable circular reference?; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'bookRepository': Requested bean is currently in creation: Is there an unresolvable circular reference?; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'library' defined in file [/home/przemek/Dropbox/projekty/farenda/java/spring-tutorial/build/classes/main/com/farenda/spring/tutorial/injection/conflict/Library.class]: Unsatisfied dependency expressed through constructor argument with index 0 of type [com.farenda.spring.tutorial.injection.conflict.BookRepository]: Error creating bean with name 'bookRepository': Requested bean is currently in creation: Is there an unresolvable circular reference?; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'bookRepository': Requested bean is currently in creation: Is there an unresolvable circular reference?2016-08-09 23:29:02.166 ERROR 11796 --- [ main] o.s.boot.SpringApplication : Application startup failedorg.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'bookRepository' defined in file [/home/przemek/Dropbox/projekty/farenda/java/spring-tutorial/build/classes/main/com/farenda/spring/tutorial/injection/conflict/BookRepository.class]: Unsatisfied dependency expressed through constructor argument with index 0 of type [com.farenda.spring.tutorial.injection.conflict.Library]: Error creating bean with name 'library' defined in file [/home/przemek/Dropbox/projekty/farenda/java/spring-tutorial/build/classes/main/com/farenda/spring/tutorial/injection/conflict/Library.class]: Unsatisfied dependency expressed through constructor argument with index 0 of type [com.farenda.spring.tutorial.injection.conflict.BookRepository]: Error creating bean with name 'bookRepository': Requested bean is currently in creation: Is there an unresolvable circular reference?; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'bookRepository': Requested bean is currently in creation: Is there an unresolvable circular reference?; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'library' defined in file [/home/przemek/Dropbox/projekty/farenda/java/spring-tutorial/build/classes/main/com/farenda/spring/tutorial/injection/conflict/Library.class]: Unsatisfied dependency expressed through constructor argument with index 0 of type [com.farenda.spring.tutorial.injection.conflict.BookRepository]: Error creating bean with name 'bookRepository': Requested bean is currently in creation: Is there an unresolvable circular reference?; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'bookRepository': Requested bean is currently in creation: Is there an unresolvable circular reference? at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:749) ~[spring-beans-4.2.6.RELEASE.jar:4.2.6.RELEASE] at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:185) ~[spring-beans-4.2.6.RELEASE.jar:4.2.6.RELEASE]The reason is that Spring Framework first tries to instantiate all the beansand then inject them. When constructor dependency is used, Spring Frameworkcannot instantiate mutually dependent beans. To fix that the beansparticipating in circular reference have to use field/setter injection.Field/setter injection to break constructor circular referencesTo fix that let’s use field injection in the beans:@Repositorypublic class BookRepository { @Autowired private Library library;// @Autowired// public BookRepository(Library library) {// this.library = library;// }//...}public class Library { @Autowired private BookRepository bookRepository;// public Library(BookRepository bookRepository) {// this.bookRepository = bookRepository;// }//...}Now Spring Framewokr can instantiate BookRepository, inject it throughthe constructor into the Library, and then inject it back to theBookRepository:2016-08-09 23:55:54.594 INFO 12472 --- [ main] c.f.s.t.i.conflict.InjectionConflict : Started InjectionConflict in 1.553 seconds (JVM running for 2.679)In a library: Public library #1Title 2: Java Concurrency in Practice2016-08-09 23:55:54.605 INFO 12472 --- [ Thread-1] s.c.a.AnnotationConfigApplicationContext : Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@2eda0940: startup date [Tue Aug 09 23:55:54 CEST 2016]; root of context hierarchyReferences: Spring Constructor Injection Spring Setter Injection Spring Field Injection" }, { "title": "Selection Sort in Java", "url": "/selection-sort-in-java/", "categories": "", "tags": "algorithms, java", "date": "2016-07-25 07:01:00 +0200", "snippet": "Selection Sort is an intuitive sorting algorithm. It’s not the fastestalgorithm, but a good starting point when learning about sorting. Also, due toits simplicity, it can be used to verify implemen...", "content": "Selection Sort is an intuitive sorting algorithm. It’s not the fastestalgorithm, but a good starting point when learning about sorting. Also, due toits simplicity, it can be used to verify implementations of harder sortingalgorithms. Let’s see how it works!How it worksThe sorting algorithm consists of 3 parts: Iterate over the input data. Find the index of the smallest number (selection), starting from thecurrent position up to the end of the given array. Swap the smallest element with the one at current position.Let’s see how that looks in the code!Selection Sort implementationThe central part of the algorithm is just the execution of the above 3 steps:public void sort(int[] values) { // 1. Iteration over the input data for (int i = 0; i &lt; values.length; i++) { // 2. Find the index of the smallest element int minPos = indexOfMinimum(values, i); // 3. Move the smallest element into the current position swap(values, i, minPos); }}To find the smallest value (minimum) in the rest of the elements, we justcompare the current minimum values[minPos] with the currently seen elementvalues[i]. If the value under the index i is smaller, we take it as thecurrent index of the smallest element minPos:private int indexOfMinimum(int[] values, int i) { int minPos = i; for (; i &lt; values.length; ++i) { if (values[i] &lt; values[minPos]) { minPos = i; } } return minPos;}And the swap of elements under the given indices - first and second:private void swap(int[] values, int first, int second) { int tmp = values[first]; values[first] = values[second]; values[second] = tmp;}Notice that all parts of the algorithm we’ve implemented in separatemethods. This make the code more readable and is a good style.If you are worried about the cost of calling methods in a loop, then no needto. JVM Hot-Spot is taking care of that and will optimize (e.g. inlinemethods) code where needed. Better focus on writing readable code!Testing the implementationLet’s write a couple of JUnit tests tomake sure that our implementation of Selection Sort behaves correctly:import org.junit.Test;import static org.junit.Assert.assertArrayEquals;public class SelectionSortTest { private SelectionSorter sorter = new SelectionSorter(); @Test public void shouldDoNothingWithEmptyArray() { int[] values = {}; sorter.sort(values); } @Test public void shouldDoNothingWithOneElementArray() { int[] values = {42}; sorter.sort(values); assertArrayEquals(new int[] {42}, values); } @Test public void shouldSortValues() { int[] values = { 9, -3, 5, 0, 1}; int[] expectedOrder = { -3, 0, 1, 5, 9}; sorter.sort(values); assertArrayEquals(expectedOrder, values); }}Selection Sort properties The running time is ϴ(n²) (Big Theta n²), which means that it won’t runfaster nor slower than n², Selection (indexOfMinimum method) will be executed n²/2 + n/2 times, Memory complexity is O(1) (constant), because the algorithm reuses theinput array.References Binary Search is expecting to receive sorted data" }, { "title": "Clojure for loop", "url": "/clojure-for-loop/", "categories": "", "tags": "clojure", "date": "2016-07-22 19:55:00 +0200", "snippet": "In Clojure the for loop looks quite differently than in most commonlanguages. Here we’re going to show how to do some interesting things with itand how it relates to Java versions.Clojure for loop,...", "content": "In Clojure the for loop looks quite differently than in most commonlanguages. Here we’re going to show how to do some interesting things with itand how it relates to Java versions.Clojure for loop, actually list comprehension (whatever that means ;-) ,is a macro with the following signature:(for [seq-exprs body-expr])It just means that for consists of two parts: seq-exps, which is just a bunch of declarations. body-expr, what should be run inside the loop.The following examples should make it clear. :-)Iteration over values(for [i (range 1 6)] i);; gives: '(1 2 3 4 5)Iteration over more values(for [x (range 1 3) y (range 6 8)] [x y]);; gives: '([1 6] [1 7] [2 6] [2 7])Think about the order of iteration as nested for loops in Java:for (int x = 1; x &lt; 3; ++x) { for (int y = 6; y &lt; 8; ++y) { new int[] {x, y}; }}For loop in Clojure allows to filter valuesUnlike in Java, but Similarly to Python’s for-loop, in Clojure we can filterthe values. The :when clause serves exactly that purpose:(for [i (range 1 11) :when (even? i)] i);; gives: '(2 4 6 8 10)It corresponds to the following code in Java:for (int i = 1; i &lt; 11; ++i) { if (isEven(i)) { numbers.add(i); }}Iterate as long as invariant holds(for [i (range 1 11) :while (&lt;= i 5)] i);; gives: '(1 2 3 4 5)Create new vars in scopeYou can use :let clause that behaves like let form and allows to createlocal variables:(for [i (range 1 6) :let [squared (* i i)]] [i squared]);; gives: '([1 1] [2 4] [3 9] [4 16] [5 25])Java counterpart:for (int i = 1; i &lt; 6; ++i) { int squared = i * i; // How to easily return pair in Java? :-)}Combination of filtering and conditional processingClauses inside for-loop can be used together. Here’s a sample filtering withchecking of invariant:(for [i (range 1 100) :while (&lt; i 10) :when (odd? i)] i);; gives: '(1 3 5 7 9)Combination of when, while, and let(for [i (range 1 100) ;; lazy sequence of 100 numbers :while (&lt; i 10) ;; limit above to only first 10 :when (even? i) ;; use only even numbers :let [tripple (* i i i)]] ;; var for readability tripple);; gives: '(8 64 216 512)The complete test that you can run:(deftest test-for-examples (testing \"Simple iteration over values\" (is (= (for [i (range 1 6)] i) '(1 2 3 4 5)))) (testing \"Iteration over two vars\" (is (= (for [x (range 1 3) y (range 6 8)] [x y]) '([1 6] [1 7] [2 6] [2 7])))) (testing \"With filtering\" (is (= (for [i (range 1 11) :when (even? i)] i) '(2 4 6 8 10)))) (testing \"As long as condition is met\" (is (= (for [i (range 1 11) :while (&lt;= i 5)] i) '(1 2 3 4 5)))) (testing \"With new vars based on iterated value\" (is (= (for [i (range 1 6) :let [squared (* i i)]] [i squared]) '([1 1] [2 4] [3 9] [4 16] [5 25])))) (testing \"when then while\" (is (= (for [i (range 1 100) :when (odd? i) :while (&lt; i 10)] i) '(1 3 5 7 9)))) (testing \"Combo\" (is (= (for [i (range 1 100) :while (&lt; i 10) :when (zero? (rem i 2)) :let [tripple (* i i i)]] tripple) '(8 64 216 512)))))References: “Programming Clojure” by Stuart Halloway and Aaron Bedra" }, { "title": "Binary Search algorithm in Java", "url": "/binary-search-algorithm-in-java/", "categories": "", "tags": "algorithms, java", "date": "2016-07-18 07:01:00 +0200", "snippet": "Binary Search is the fastest algorithm for finding an element in a sortedlist. Also it’s easy to implement and very useful. Let’s see how it works andimplement!How it worksThe procedure is simple: ...", "content": "Binary Search is the fastest algorithm for finding an element in a sortedlist. Also it’s easy to implement and very useful. Let’s see how it works andimplement!How it worksThe procedure is simple: Take element from the center and compare with expected value. If found return its index. If expected value is bigger, repeat from step 1, but only for part of arrayfrom the second half. Because the array is sorted we know that everythingfrom the first half is smaller than the target element, so no need to compare. If expected value is lower, repeat from step 1, but only for part of arrayfrom the first half. Return some value that indicates that the expected value was not found(usually -1) or negative_index - 1 of place where it can be inserted, tosimplify insertion for users (optional, but easy to do).Binary Search properties input array/list must be sorted computational complexity in the worst case is O(log n + 1) (when elementis not found), best is O(1) (hit on the first guess) returns index of target element when found returns negative index minus one of the insertion point of the targetelement, in case when was not foundBinary Search implementationIn this implementation we are working with integers, but it can be easilychanges to work with any objects that are comparable (or by providing a customComparator):public class BinarySearch { public static int find(int[] numbers, int target) { int min = 0, max = numbers.length-1; while (min &lt;= max) { int pos = (min+max) / 2; if (numbers[pos] == target) { return pos; } if (numbers[pos] &lt; target) { min = pos + 1; } else { max = pos - 1; } } // +1, because 0 belongs to positive indices return -(min+1); }}Unit testingLet’s write some unit tests to verify ourimplementation. We can use Fibonacci numbersas our sorted array of numbers:import java.util.Arrays;import org.junit.Test;import static org.junit.Assert.assertEquals;public class BinarySearchTest { private static final int[] FIBOS = { 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 }; // Tests will go here:}Test to check that numbers are found correctlyHere we’ve added calls to binarySearch method from java.util.Arrays just tocompare the results produced by both implementations:@Testpublic void shouldFindIndexOfNumber() { // Our version: assertEquals(3, BinarySearch.find(FIBOS, 3)); assertEquals(9, BinarySearch.find(FIBOS, 55)); // JDK version: assertEquals(3, Arrays.binarySearch(FIBOS, 3)); assertEquals(9, Arrays.binarySearch(FIBOS, 55));}Test to check insertion pointIn the case when expected number is not found it’s easy to return a pointer to aplace where it can be inserted. Here we’re going to verify it works:@Testpublic void shouldReturnNegativeInsertionPointWhenNotFound() { // Our version: assertEquals(-1, BinarySearch.find(FIBOS, 0)); assertEquals(-5, BinarySearch.find(FIBOS, 4)); // JDK version: assertEquals(-1, Arrays.binarySearch(FIBOS, 0)); assertEquals(-5, Arrays.binarySearch(FIBOS, 4));}References JUnit Tutorial Java BinarySearch with custom Comparator" }, { "title": "Spring Field Injection", "url": "/spring-field-injection/", "categories": "", "tags": "java, spring", "date": "2016-07-12 07:01:00 +0200", "snippet": "This is the form of Dependency Injection that requires almost no boilerplatecode, contrary to setter or constructor injections. Let’s see how it works!Spring bean to inject as dependencyTo start wi...", "content": "This is the form of Dependency Injection that requires almost no boilerplatecode, contrary to setter or constructor injections. Let’s see how it works!Spring bean to inject as dependencyTo start with, we’ll specify an interface for the dependency:package com.farenda.spring.tutorial.injection.field;public interface BookRepository { String titleById(int id);}And the actual Spring Bean implementation that will be injected:package com.farenda.spring.tutorial.injection.field;import org.springframework.stereotype.Repository;import java.util.HashMap;import java.util.Map;@Repositorypublic class InMemoryBookRepository implements BookRepository { // It's our local database ;-) private Map&lt;Integer, String&gt; books = new HashMap&lt;&gt;(); { books.put(1, \"Effective Java, 3rd edition\"); books.put(2, \"Java Concurrency in Practice\"); books.put(3, \"Spring in Action\"); } @Override public String titleById(int id) { return books.get(id); }}Spring component with dependency injected using field injectionHere we define another Spring Bean, but we are going to inject /BookRepository/using field injection. To do that we have to annotate appropriate fields using@Autowired (or @Inject or @Resource) annotation:package com.farenda.spring.tutorial.injection.field;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;@Componentpublic class Library { @Autowired private BookRepository bookRepository; public String findBook(int id) { return bookRepository.titleById(id); }}It works without any setter, because underneath Spring is using reflection toinject dependencies.Constructor or field injectionAlthough constructor injection allows to create beans as immutable objects(fields can be marked using final modifier) and makes dependencies explicitit requires to write some boilerplate code. Because of that, in practice, fieldinjection is used.Example App using Spring BootHere’s the simplest Spring Boot application to run the above code:package com.farenda.spring.tutorial.injection.field;import org.springframework.boot.SpringApplication;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScanpublic class FieldInjection { public static void main(String[] args) { ApplicationContext context = SpringApplication .run(FieldInjection.class, args); Library library = context.getBean(Library.class); System.out.println(\"Title 1: \" + library.findBook(1)); System.out.println(\"Title 2: \" + library.findBook(2)); }}The above code produces the following output:Title 1: Effective Java, 3rd editionTitle 2: Java Concurrency in PracticeReferences: Spring Reference Documentation Spring Constructor Injection Spring Setter Injection" }, { "title": "Spring Constructor Injection", "url": "/spring-constructor-injection/", "categories": "", "tags": "java, spring", "date": "2016-06-13 07:01:00 +0200", "snippet": "This is one of the simplest and cleanest types of Dependency Injection inthe Spring Framework. In this post we show how to use it with help ofSpring annotations.Spring bean to inject as dependencyL...", "content": "This is one of the simplest and cleanest types of Dependency Injection inthe Spring Framework. In this post we show how to use it with help ofSpring annotations.Spring bean to inject as dependencyLet’s specify an interface for dependency:package com.farenda.spring.tutorial.injection.constructor;public interface BookRepository { String titleById(int id);}And the actual Spring Bean implementation that will be injected:package com.farenda.spring.tutorial.injection.constructor;import org.springframework.stereotype.Repository;import java.util.HashMap;import java.util.Map;@Repositorypublic class InMemoryBookRepository implements BookRepository { // It's our local database ;-) private Map&lt;Integer, String&gt; books = new HashMap&lt;&gt;(); { books.put(1, \"Effective Java, 2nd edition\"); books.put(2, \"Java Concurrency in Practice\"); books.put(3, \"Spring in Action\"); } @Override public String titleById(int id) { return books.get(id); }}Spring component with dependency injected by constructorHere we define another Spring Bean, but this time we are going to injectBookRepository through constructor, using @Autowired annotation:package com.farenda.spring.tutorial.injection.constructor;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;@Componentpublic class Library { private BookRepository bookRepository; @Autowired public Library(BookRepository bookRepository) { this.bookRepository = bookRepository; } public String findBook(int id) { return bookRepository.titleById(id); }}Spring resolves dependencies using argument’s type. If it finds a beanmatching the type, then the bean is instantiated and injected. Else exception isthrown.Example App using Spring BootHere’s the simplest Spring Boot application to run the above code:package com.farenda.spring.tutorial.injection.constructor;import org.springframework.boot.SpringApplication;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan // scan this package for Spring beanspublic class ConstructorInjection { public static void main(String[] args) { ApplicationContext context = SpringApplication .run(ConstructorInjection.class, args); // Get bean from the Spring Application Context: Library library = context.getBean(Library.class); System.out.println(\"Title 1: \" + library.findBook(1)); System.out.println(\"Title 2: \" + library.findBook(2)); }}The above code produces the following output:Title 1: Effective Java, 2nd editionTitle 2: Java Concurrency in PracticeReferences: Check out Spring Boot “Hello, world” if you are new to Spring Boot" }, { "title": "How to mock Java classes in Clojure", "url": "/clojure-mock-java-class/", "categories": "", "tags": "clojure", "date": "2016-04-26 07:01:00 +0200", "snippet": "In this post we’re going to show how to use Clojure proxy to mock Javaclasses and provide own functionality for Java methods.Proxy class with no-arg constructorCalls superclass default constructor:...", "content": "In this post we’re going to show how to use Clojure proxy to mock Javaclasses and provide own functionality for Java methods.Proxy class with no-arg constructorCalls superclass default constructor:(def my-list (proxy [ArrayList] [] (get [i] 42)));; Let's use it:;; user&gt; (.get my-list 10);; 42No matching ctor found for classSuperclass has no no-arg constructor:(proxy [FileInputStream] [] (read [] 42))Produces an exception, because there’s no no-arg constructor inFileInputStream class:CompilerException java.lang.IllegalArgumentException: No matching ctor found for class user.proxy$java.io.FileInputStream$ff19274aProxy java class with constructorWe have to provide obligatory constructor parameter (here “/proc/version”), thatwill be passed to superclass:;; To count calls and return predictive values:(def counter (atom 0))(def my-mock (proxy [FileInputStream] [\"/proc/version\"] (read [] (swap! counter inc))))Now our version of read method may be called as expected:user&gt; (.read my-mock)1user&gt; (.read my-mock)2user&gt; (.read my-mock)3Overload mocked method(def counter (atom 0))(def my-mock (proxy [FileInputStream] [\"/proc/version\"] (read ([] (swap! counter inc)) ; read() ([^bytes arr] ; read(byte[]) (aset-byte arr 0 42) (swap! counter inc)))))read(byte[]) can be called like this:user&gt; (.read my-mock (byte-array 3))1user&gt; (.read my-mock (byte-array 3))2References: proxy macro ClojureDocs - proxy" }, { "title": "Spring component scan exclude", "url": "/spring-component-scan-exclude/", "categories": "", "tags": "java, spring", "date": "2015-12-21 06:01:00 +0100", "snippet": "How to exclude classes/packages from Component Scan in Spring Framework? Thetask is a bit tricky, especially when regexp is involved. See how it works!Example Spring beansLet’s say that we’ve got t...", "content": "How to exclude classes/packages from Component Scan in Spring Framework? Thetask is a bit tricky, especially when regexp is involved. See how it works!Example Spring beansLet’s say that we’ve got the following two classes incom.farenda.java.spring.excludescan package:package com.farenda.java.spring.excludescan;import org.springframework.stereotype.Service;@Servicepublic class ExcludedService { public ExcludedService() { System.out.println(\"Instantiating \" + getClass().getSimpleName()); }}package com.farenda.java.spring.excludescan;import org.springframework.stereotype.Service;@Servicepublic class IncludedService { public IncludedService() { System.out.println(\"Instantiating \" + getClass().getSimpleName()); }}We want to scan the whole package and include every component exceptExcludedService. In our case included beans should contain onlyIncludedService.ComponentScan exclude - using annotationsTo exclude some beans we can use excludeFilters on the @ComponentScanannotation like this:package com.farenda.java.spring;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.*;import org.springframework.context.annotation.ComponentScan.Filter;import java.util.Arrays;@ComponentScan(basePackages = \"com.farenda.java.spring.excludescan\", excludeFilters =@Filter( type = FilterType.REGEX, pattern = \"com\\\\.farenda\\\\.java\\\\.spring\\\\.excludescan\\\\.Excluded.*\"))@EnableAutoConfigurationpublic class ExcludingFromComponentScanExample { public static void main(String[] args) throws Exception { ApplicationContext context = SpringApplication.run(ExcludingFromComponentScanExample.class, args); String[] beans = context.getBeanDefinitionNames(); // sort names only to make output more readable: Arrays.sort(beans); System.out.println(\"Defined beans: \"); for (String bean : beans) { System.out.println(bean); } }}We apply REGEX FilterType that allows us nicely exclude single classes andwhole packages. When we run the application you can see that onlyincludedService is among beans in ApplicationContext built from ComponentScan:... :: Spring Boot :: (v1.2.3.RELEASE)2015-12-20 13:08:37.601 INFO 4077 --- [ main] .f.j.s.ExcludingFromComponentScanExample2015-12-20 13:08:37.660 INFO 4077 --- [ main] s.c.a.AnnotationConfigApplicationContextInstantiating IncludedService...2015-12-20 13:08:39.292 INFO 4077 --- [ main] .f.j.s.ExcludingFromComponentScanExample : Started ExcludingFromComponentScanExample in 2.204 seconds (JVM running for 2.841)Defined beans:excludingFromComponentScanExampleincludedServicembeanExportermbeanServerobjectNamingStrategyorg.springframework.boot.autoconfigure.AutoConfigurationPackagesorg.springframework.boot.autoconfigure.PropertyPlaceholderAutoConfigurationorg.springframework.boot.autoconfigure.condition.BeanTypeRegistryorg.springframework.boot.autoconfigure.jmx.JmxAutoConfigurationorg.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessororg.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessororg.springframework.context.annotation.internalAutowiredAnnotationProcessororg.springframework.context.annotation.internalCommonAnnotationProcessororg.springframework.context.annotation.internalConfigurationAnnotationProcessororg.springframework.context.annotation.internalRequiredAnnotationProcessorpropertySourcesPlaceholderConfigurer2015-12-20 13:08:39.295 INFO 4077 --- [ Thread-1] s.c.a.AnnotationConfigApplicationContext : Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@7a187f14: startup date [Sun Dec 20 13:08:37 CET 2015]; root of context hierarchy2015-12-20 13:08:39.298 INFO 4077 --- [ Thread-1] o.s.j.e.a.AnnotationMBeanExporter : Unregistering JMX-exposed beans on shutdownProcess finished with exit code 0The same filtering mechanism can be used with includeFilters attribute, toselect classes/packages that should be included in Spring ApplicationContext.ComponentScan exclude - XML versionIf you happen to still work with XML Spring Configuration, then the same thingcan be done in the following way:&lt;context:component-scan base-package=\"com.farenda.java.spring.excludescan\"&gt; &lt;context:exclude-filter type=\"regex\" expression=\"com\\.farenda\\.java\\.spring\\.excludescan\\.Excluded.*\"/&gt;&lt;/context:component-scan&gt;Resources Check out Spring Framework Tutorial!" }, { "title": "Spring find annotated classes", "url": "/spring-find-annotated-classes/", "categories": "", "tags": "java, spring", "date": "2015-08-24 07:01:00 +0200", "snippet": "How to find annotated classes using Spring Framework and read metadata fromthem? Sometimes you may want to attach metadata to your classes using customannotations. Here’s an example how you can lev...", "content": "How to find annotated classes using Spring Framework and read metadata fromthem? Sometimes you may want to attach metadata to your classes using customannotations. Here’s an example how you can leverage Spring’s classpathscanning mechanism to do that.The Spring Bean problemIf you use Spring annotations like @Component, @Repository or@Service, then Spring will find such classes, but will make them Springbeans.Classpath Scanner customizationGood news is that Spring classpath scanning mechanism is configurable andavailable in any Spring application. To use custom annotations we have tocreate an instance of ClassPathScanningCandidateComponentProvider and setappropriate filter - here it is AnnotationTypeFilter. It returnsBeanDefinitions that contains names of found class from which we can getdetailed information. The following example will clarify that.Own annotationsWe create our custom annotation that allows us to attach some metatdata:package com.farenda.java.lang;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;// Make the annotation available at runtime:@Retention(RetentionPolicy.RUNTIME)// Allow to use only on types:@Target(ElementType.TYPE)public @interface Findable { /** * User friendly name of annotated class. */ String name();}Adding metadata to own classesSample classes annotated with the custom annotation:package com.farenda.java.lang;@Findable(name = \"Find me\")public class FirstAnnotatedClass {}package com.farenda.java.lang;@Findable(name = \"Find me too\")public class SecondAnnotatedClass {}Spring dependencyThe classpath scanner is provided by spring-context project. Here’s therelevant Maven dependency:&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.2.0.RELEASE&lt;/version&gt;&lt;/dependency&gt;The ScannerThe Java code below is using ClassPathScanningCandidateComponentProviderto scan classes in com.farenda.java.lang package.package com.farenda.java.lang;import org.springframework.beans.factory.config.BeanDefinition;import org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider;import org.springframework.core.type.filter.AnnotationTypeFilter;public class SpringClassScanner { public static void main(String[] args) throws Exception { System.out.println(\"Finding annotated classes using Spring:\"); new SpringClassScanner().findAnnotatedClasses(\"com.farenda.java.lang\"); } public void findAnnotatedClasses(String scanPackage) { ClassPathScanningCandidateComponentProvider provider = createComponentScanner(); for (BeanDefinition beanDef : provider.findCandidateComponents(scanPackage)) { printMetadata(beanDef); } } private ClassPathScanningCandidateComponentProvider createComponentScanner() { // Don't pull default filters (@Component, etc.): ClassPathScanningCandidateComponentProvider provider = new ClassPathScanningCandidateComponentProvider(false); provider.addIncludeFilter(new AnnotationTypeFilter(Findable.class)); return provider; } private void printMetadata(BeanDefinition beanDef) { try { Class&lt;?&gt; cl = Class.forName(beanDef.getBeanClassName()); Findable findable = cl.getAnnotation(Findable.class); System.out.printf(\"Found class: %s, with meta name: %s%n\", cl.getSimpleName(), findable.name()); } catch (Exception e) { System.err.println(\"Got exception: \" + e.getMessage()); } }}The code is straightforward. The hardest thing is to type and read very longnames of Spring classes. ;-)And here’s the output of running the code:Finding annotated classes using Spring:Found class: SecondAnnotatedClass, with meta name: Find me tooFound class: FirstAnnotatedClass, with meta name: Find meSummaryThis sort of scanning is very good fit for applications that already useSpring Framework. However, in the future, we’ll see how to solve the sameproblem, but without Spring." }, { "title": "Clojure switch-case", "url": "/clojure-switch-case/", "categories": "", "tags": "clojure", "date": "2015-07-28 07:01:00 +0200", "snippet": "One of the first control flow statements in many programming languages isswitch-case. In Clojure switch-case can be achieved in different ways, whatwe will show in this article.The case macroThere ...", "content": "One of the first control flow statements in many programming languages isswitch-case. In Clojure switch-case can be achieved in different ways, whatwe will show in this article.The case macroThere are a couple of functions/macros in Clojure that serve asswitch-case control flow statements. The first one is case macro:(defn case-example [word] (case word \"saluton\" \"Esperanto!\" \"hi\" \"English\" \"Unknown\"))It takes an expression (here word evaluates to its value), tries to matchits result with constant in the first column and returns value from the rightcolumn when it matches.A default value can be provided as a single value, without testexpression. If default value is not provided and there is no match thenIllegalArgumentException is thrown.Let’s test that:(deftest test-case-examples (testing \"case example\" (is (= \"Unknown\" (case-example \"aoeu\"))) (is (= \"English\" (case-example \"hi\"))) (is (= \"Esperanto!\" (case-example \"saluton\")))))The cond macroThe next approach to switch-case in Clojure is cond macro:(defn cond-example [p] (cond (&lt; (count p) 8) \"too short\" (&lt; 32 (count p)) \"too long\" :else \"ok\"))It takes a number of pairs test expression and a value. When testexpression matches, then the value is returned. The last expression is :else,which, as other keywords, evaluates to itself. It could be anything whichevaluates itself to boolean true, however, :else is commonly used for thatpurpose.When there is no default, the case returns nil.Running the code gives:(deftest test-cond-examples (testing \"cond example\" (is (= (cond-example \"abc\") \"too short\")) (is (= (cond-example \"very long string\") \"too long\")) (is (nil? (cond-example \"ok one\")))))The condp macroThe last one is condp:(defn condp-example [op a b] (condp = op + (+ a b) - (- a b) \"Unknown operator\"))Clojure condp macro takes a binary predicate (here =) and an expression(here op from the parameters) and a number of pairs test-expressionresult-expression. For each clause the following expression is evaluated:(pred test-expr expr). So, for arguments '+ 1 2 it would be (= '+'+). When the test expression returns true then the result expression isevaluated and returned.Default value is indicated by the line without separate test expression.When no default value is provided, condp will throw IllegalArgumentExceptionif nothing matches.Running the example gives:(deftest test-condp-examples (testing \"condp example\" (is (= (condp-example + 1 2) 3)) (is (= (condp-example - 1 2) -1)) (is (= (condp-example * 1 2) \"Unknown operator\"))))What next?Now switching from Java switch-case to Clojure switch-case should be a breeze. ;-)Check out other Clojure articles!" }, { "title": "Spring Boot \"Hello, World\"", "url": "/spring-boot-hello-world/", "categories": "", "tags": "java, spring", "date": "2015-06-09 10:05:00 +0200", "snippet": "Problem:How to create “Hello, World” app in Spring Boot?Solution:Gradle build script will all required dependencies:buildscript { repositories { jcenter() maven { url \"http://repo....", "content": "Problem:How to create “Hello, World” app in Spring Boot?Solution:Gradle build script will all required dependencies:buildscript { repositories { jcenter() maven { url \"http://repo.spring.io/snapshot\" } maven { url \"http://repo.spring.io/milestone\" } } dependencies { // Provides tasks to create executable JAR and run project from source. // It also adds ResolutionStrategy, which allows to ommit versions in // \"blessed\" dependencies below. classpath(\"org.springframework.boot:spring-boot-gradle-plugin:1.2.3.RELEASE\") }}apply plugin: 'java'apply plugin: 'spring-boot'jar { baseName = 'spring-boot-hello-world' version = '0.0.1-SNAPSHOT'}repositories { jcenter() maven { url \"http://repo.spring.io/snapshot\" } maven { url \"http://repo.spring.io/milestone\" }}dependencies { compile(\"org.springframework.boot:spring-boot-starter-web\") testCompile(\"org.springframework.boot:spring-boot-starter-test\")}Sample REST service to show how it is to do it with Spring Boot:package com.farenda.java.spring;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;// Tells Spring to consider this bean for handling incoming web requests@Controller// Tells Spring to guess application type based on its dependencies and// setup application context accordingly:@EnableAutoConfigurationpublic class JavaSolved { // Make application accessible under http://localhost:8080/ path: @RequestMapping(\"/\") // Tells to convert return value into HTTP response: @ResponseBody String home() { return \"Hello, Spring Boot World!\"; } public static void main(String[] args) throws Exception { // Lets Spring bootstrap the application with // preconfigured Tomcat. The class name is used // to indicate primary Spring component: SpringApplication.run(JavaSolved.class, args); }}Result:Execute “gradle bootRun” from the console and open http://localhost:8080 toaccess the app:$&gt; gradle bootRun:compileJava:processResources UP-TO-DATE:classes:findMainClass:bootRun . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.2.3.RELEASE)[... a lot of lines ...]2015-06-06 18:20:19.896 INFO 9273 --- [ main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)2015-06-06 18:20:19.906 INFO 9273 --- [ main] com.farenda.solved.JavaSolved : Started JavaSolved in 5.255 seconds (JVM running for 6.0)Let’s use curl to check the result:$&gt; curl localhost:8080Hello, Spring Boot World!It works as advertised!" }, { "title": "Spring Boot REST HATEOAS", "url": "/spring-boot-rest-hateoas/", "categories": "", "tags": "java, spring", "date": "2015-05-27 18:24:00 +0200", "snippet": "Problem:How to create simple Spring Boot REST service with HATEOAS support?It’s very simple with spring-boot-hateoas project.Solution:Project configuration for Gradle (build.gradle):apply plugin: '...", "content": "Problem:How to create simple Spring Boot REST service with HATEOAS support?It’s very simple with spring-boot-hateoas project.Solution:Project configuration for Gradle (build.gradle):apply plugin: 'java'apply plugin: 'groovy'apply plugin: 'idea'apply plugin: 'spring-boot'sourceCompatibility = 1.8targetCompatibility = 1.8buildscript { repositories { mavenCentral() } dependencies { classpath(\"org.springframework.boot:spring-boot-gradle-plugin:1.2.3.RELEASE\") }}jar { baseName = 'spring-boot-rest-hateoas-sample' version = '0.1.0'}repositories { mavenCentral()}dependencies { // Dependencies for Spring Boot with REST HATEOAS: compile \"com.fasterxml.jackson.core:jackson-databind\" compile \"com.jayway.jsonpath:json-path:0.9.1\" compile \"org.springframework.boot:spring-boot-starter-hateoas\" // Dependencies for Spock tests: compile \"org.codehaus.groovy:groovy-all:2.4.1\" testCompile \"org.spockframework:spock-core:1.0-groovy-2.4\" testCompile \"org.spockframework:spock-spring:1.0-groovy-2.4\" testCompile \"org.springframework.boot:spring-boot-starter-test\"}In TDD we start with a test, so createsrc/test/groovy/com/farenda/java/spring/EchoServiceTest.groovy with the followingcontent:package com.farenda.java.springimport com.fasterxml.jackson.databind.ObjectMapperimport org.springframework.beans.factory.annotation.Valueimport org.springframework.boot.test.SpringApplicationContextLoaderimport org.springframework.boot.test.TestRestTemplateimport org.springframework.boot.test.WebIntegrationTestimport org.springframework.hateoas.MediaTypesimport org.springframework.hateoas.ResourceSupportimport org.springframework.hateoas.hal.Jackson2HalModuleimport org.springframework.hateoas.mvc.TypeConstrainedMappingJackson2HttpMessageConverterimport org.springframework.http.HttpStatusimport org.springframework.http.converter.HttpMessageConverterimport org.springframework.test.context.ContextConfigurationimport spock.lang.Sharedimport spock.lang.Specification// Need to specify \"loader\" here to workaround Spock issue// with meta annotations:// https://code.google.com/p/spock/issues/detail?id=349@ContextConfiguration(classes = [HateoasExample], loader = SpringApplicationContextLoader)// Tell Spring to start Web Server on random port, because// usual 8080 may be busy:@WebIntegrationTest(randomPort = true)class EchoServiceTest extends Specification { // Inject random port of test Web Server: @Value('${local.server.port}') def int serverPort @Shared def rest = getRestTemplateWithHalMessageConverter() // Registered converters are processed in order, so it's // not enough to add the new one - we need to add it at // the beginning, so it can process before generic JSON // converter, else HAL links won't be interpreted! def TestRestTemplate getRestTemplateWithHalMessageConverter() { def restTemplate = new TestRestTemplate() restTemplate.getMessageConverters().add(0, halMessageConverter()) return restTemplate } // Needed to interpret HAL \"_links\". Without this // response will be with empty links! private static HttpMessageConverter halMessageConverter() { def objectMapper = new ObjectMapper().registerModule(new Jackson2HalModule()) def halConverter = new TypeConstrainedMappingJackson2HttpMessageConverter(ResourceSupport) halConverter.setSupportedMediaTypes([MediaTypes.HAL_JSON]) halConverter.setObjectMapper(objectMapper) return halConverter } def 'should receive sent message with self link'() { given: // toString() is only to convert from GString to a String: def url = \"http://localhost:${serverPort}/echo?message=\".toString() def query = url + '{message}' def myMessage = 'HelloWorld!' when: // Post GET to the service and receive response as ResponseEntity. // We want ResponseEntity to verify HttpStatus code and links. // The last parameter can also be a map: [message:myMessage] def response = rest.getForEntity(query, EchoResource, myMessage) then: response.statusCode == HttpStatus.OK response.body.message == myMessage response.body.getLinks().size() == 1 response.body.getLink('self').href == url+myMessage }}Now, we’ve got a failing test. So here’s the service:Spring Boot config for the app:package com.farenda.java.spring;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class HateoasExample { public static void main(String[] args) throws Exception { SpringApplication.run(HateoasExample.class, args); }}@SpringBootApplication gives @Component, @Configuration, and@EnableAutoConfiguration for free.REST HATEOAS resource:package com.farenda.java.spring;import com.fasterxml.jackson.annotation.JsonCreator;import com.fasterxml.jackson.annotation.JsonProperty;import org.springframework.hateoas.ResourceSupport;// Created separate class for \"only\" message to have// also HATEOAS \"links\" from ResourceSupport - see// EchoService for usage.public class EchoResource extends ResourceSupport { private final String message; @JsonCreator public EchoResource(@JsonProperty(\"message\") String message) { this.message = message; } public String getMessage() { return message; }}And, finally, Spring REST HATEOAS service:package com.farenda.java.spring;import org.springframework.http.HttpEntity;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import static org.springframework.hateoas.mvc.ControllerLinkBuilder.linkTo;import static org.springframework.hateoas.mvc.ControllerLinkBuilder.methodOn;// It's like @Controller, but automatically assumes @ResponseBody.@RestControllerpublic class EchoService { @RequestMapping(\"/echo\") public HttpEntity&lt;EchoResource&gt; echo( @RequestParam(\"message\") String message) { EchoResource resource = new EchoResource(message); // Nice DSL for creating links. Here we don't have // other actions, so the only link is \"self\": resource.add(linkTo(methodOn(EchoService.class).echo(message)) .withSelfRel()); return new ResponseEntity&lt;&gt;(resource, HttpStatus.OK); }}Result:You can run Spock tests as usual:$&gt; gradle testAlso you can start the app and verify it:$&gt; gradle bootRun$&gt; curl http://localhost:8080/echo?message=Drakaris!{ \"message\": \"Drakaris!\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/echo?message=Drakaris!\" } }}" } ]
