<!DOCTYPE html><html lang="en" data-mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.4" /><meta property="og:title" content="Parallel Merge Sort in Java" /><meta property="og:locale" content="en" /><meta name="description" content="Divide and Conquer algorithms are great subject for parallelism. Here we present Parallel Merge Sort implemented using Java ForkJoin Framework. Parallel sort steps Parallel Merge Sort consists of the same steps as other tasks executed in ForkJoin Pool, namely: If the task is small enough - do it directly. In case of Merge Sort we can decide that when a subarray to sort is smaller than some value (we name it SORT_THRESHOLD), then we’ll use Insertion Sort, which will sort it in-place. Else do Merge Sort of both parts as separate tasks, executed in a ForkJoin Pool. This will allow us to sort parts of an array independently and then just merge them. MergSort as RecursiveAction The implementation consists of a few key points we need to do: extend RecursiveAction to allow execution in ForkJoin Pool decide when to sort directly execute parallel tasks for subarrays merge everything at the end. Therefore the heart of the Parallel Merge Sort with Fork Join Framework looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import java.util.concurrent.RecursiveAction; public class ParallelMergeSort extends RecursiveAction { // Decides when to fork or compute directly: private static final int SORT_THRESHOLD = 128; // Defines subarray to sort: public ParallelMergeSort(int[] values, int from, int to) @Override protected void compute() { if (from &lt; to) { int size = to - from; if (size &lt; SORT_THRESHOLD) { // Sort in-place using Insertion Sort: insertionSort(); } else { int mid = from + Math.floorDiv(size, 2); // Do MergeSort in parallel on subarrays. // This will submit the tasks to the current // ForkJoin Pool: invokeAll( new ParallelMergeSort(values, from, mid), new ParallelMergeSort(values, mid + 1, to)); // Merge sorted subarrays: merge(mid); } } } // ... } Complete Parallel Merge Sorter This is complete implementation of Parallel Merge Sort using Fork-Join Framework to do parallel execution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 import java.util.Arrays; import java.util.concurrent.RecursiveAction; public class ParallelMergeSort extends RecursiveAction { // Decides when to fork or compute directly: private static final int SORT_THRESHOLD = 128; private final int[] values; private final int from; private final int to; public ParallelMergeSort(int[] values) { this(values, 0, values.length-1); } public ParallelMergeSort(int[] values, int from, int to) { this.values = values; this.from = from; this.to = to; } public void sort() { compute(); } @Override protected void compute() { if (from &lt; to) { int size = to - from; if (size &lt; SORT_THRESHOLD) { insertionSort(); } else { int mid = from + Math.floorDiv(size, 2); invokeAll( new ParallelMergeSort(values, from, mid), new ParallelMergeSort(values, mid + 1, to)); merge(mid); } } } private void insertionSort() { for (int i = from+1; i &lt;= to; ++i) { int current = values[i]; int j = i-1; while (from &lt;= j &amp;&amp; current &lt; values[j]) { values[j+1] = values[j--]; } values[j+1] = current; } } private void merge(int mid) { int[] left = Arrays.copyOfRange(values, from, mid+1); int[] right = Arrays.copyOfRange(values, mid+1, to+1); int f = from; int li = 0, ri = 0; while (li &lt; left.length &amp;&amp; ri &lt; right.length) { if (left[li] &lt;= right[ri]) { values[f++] = left[li++]; } else { values[f++] = right[ri++]; } } while (li &lt; left.length) { values[f++] = left[li++]; } while (ri &lt; right.length) { values[f++] = right[ri++]; } } } Test and performance comparison As usually we need to check somehow that it works. :wink: But for brevity we’ll show only JUnit test for substantial amount of data (100 millions) and we’ll do that for both Merge Sort and Parallel Merge Sort: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import org.junit.Test; import java.util.Arrays; import java.util.Random; import static org.junit.Assert.assertArrayEquals; public class ParallelMergeSortTest { //... other tests cut for brevity @Test public void performanceTest() { int[] serial = new Random().ints(100_000_000).toArray(); int[] parallel = Arrays.copyOf(serial, serial.length); MergeSort mergeSort = new MergeSort(); long start = System.currentTimeMillis(); mergeSort.sort(serial); System.out.println(&quot;Merge Sort done in: &quot; + (System.currentTimeMillis()-start)); ParallelMergeSort sorter = new ParallelMergeSort(parallel); start = System.currentTimeMillis(); sorter.sort(); System.out.println(&quot;Parallel Merge Sort done in: &quot; + (System.currentTimeMillis()-start)); assertArrayEquals(parallel, serial); } } I run that a few times on my laptop with 2 cores and the results were around this: 1 2 Merge Sort done in: 31077 Parallel Merge Sort done in: 20020 Clearly Parallel Merge Sort is much faster for arrays of 100M of elements. The speedup is not 2x, because there are overheads for scheduling tasks in pool, but still the difference is substantial. Both sorting algorithms use Insertion Sort when subarray to sort is below defined threshold. I found value 128 to give pretty good results in my environment - maybe there is a better value around, but, in my case, it gave better results than values 64, 256, 512, 768, 1024, etc. References See details of Insertion Sort See detailed explanation of Merge Sort ForkJoin explained Check out other algorithms in Algorithms section" /><meta property="og:description" content="Divide and Conquer algorithms are great subject for parallelism. Here we present Parallel Merge Sort implemented using Java ForkJoin Framework. Parallel sort steps Parallel Merge Sort consists of the same steps as other tasks executed in ForkJoin Pool, namely: If the task is small enough - do it directly. In case of Merge Sort we can decide that when a subarray to sort is smaller than some value (we name it SORT_THRESHOLD), then we’ll use Insertion Sort, which will sort it in-place. Else do Merge Sort of both parts as separate tasks, executed in a ForkJoin Pool. This will allow us to sort parts of an array independently and then just merge them. MergSort as RecursiveAction The implementation consists of a few key points we need to do: extend RecursiveAction to allow execution in ForkJoin Pool decide when to sort directly execute parallel tasks for subarrays merge everything at the end. Therefore the heart of the Parallel Merge Sort with Fork Join Framework looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import java.util.concurrent.RecursiveAction; public class ParallelMergeSort extends RecursiveAction { // Decides when to fork or compute directly: private static final int SORT_THRESHOLD = 128; // Defines subarray to sort: public ParallelMergeSort(int[] values, int from, int to) @Override protected void compute() { if (from &lt; to) { int size = to - from; if (size &lt; SORT_THRESHOLD) { // Sort in-place using Insertion Sort: insertionSort(); } else { int mid = from + Math.floorDiv(size, 2); // Do MergeSort in parallel on subarrays. // This will submit the tasks to the current // ForkJoin Pool: invokeAll( new ParallelMergeSort(values, from, mid), new ParallelMergeSort(values, mid + 1, to)); // Merge sorted subarrays: merge(mid); } } } // ... } Complete Parallel Merge Sorter This is complete implementation of Parallel Merge Sort using Fork-Join Framework to do parallel execution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 import java.util.Arrays; import java.util.concurrent.RecursiveAction; public class ParallelMergeSort extends RecursiveAction { // Decides when to fork or compute directly: private static final int SORT_THRESHOLD = 128; private final int[] values; private final int from; private final int to; public ParallelMergeSort(int[] values) { this(values, 0, values.length-1); } public ParallelMergeSort(int[] values, int from, int to) { this.values = values; this.from = from; this.to = to; } public void sort() { compute(); } @Override protected void compute() { if (from &lt; to) { int size = to - from; if (size &lt; SORT_THRESHOLD) { insertionSort(); } else { int mid = from + Math.floorDiv(size, 2); invokeAll( new ParallelMergeSort(values, from, mid), new ParallelMergeSort(values, mid + 1, to)); merge(mid); } } } private void insertionSort() { for (int i = from+1; i &lt;= to; ++i) { int current = values[i]; int j = i-1; while (from &lt;= j &amp;&amp; current &lt; values[j]) { values[j+1] = values[j--]; } values[j+1] = current; } } private void merge(int mid) { int[] left = Arrays.copyOfRange(values, from, mid+1); int[] right = Arrays.copyOfRange(values, mid+1, to+1); int f = from; int li = 0, ri = 0; while (li &lt; left.length &amp;&amp; ri &lt; right.length) { if (left[li] &lt;= right[ri]) { values[f++] = left[li++]; } else { values[f++] = right[ri++]; } } while (li &lt; left.length) { values[f++] = left[li++]; } while (ri &lt; right.length) { values[f++] = right[ri++]; } } } Test and performance comparison As usually we need to check somehow that it works. :wink: But for brevity we’ll show only JUnit test for substantial amount of data (100 millions) and we’ll do that for both Merge Sort and Parallel Merge Sort: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import org.junit.Test; import java.util.Arrays; import java.util.Random; import static org.junit.Assert.assertArrayEquals; public class ParallelMergeSortTest { //... other tests cut for brevity @Test public void performanceTest() { int[] serial = new Random().ints(100_000_000).toArray(); int[] parallel = Arrays.copyOf(serial, serial.length); MergeSort mergeSort = new MergeSort(); long start = System.currentTimeMillis(); mergeSort.sort(serial); System.out.println(&quot;Merge Sort done in: &quot; + (System.currentTimeMillis()-start)); ParallelMergeSort sorter = new ParallelMergeSort(parallel); start = System.currentTimeMillis(); sorter.sort(); System.out.println(&quot;Parallel Merge Sort done in: &quot; + (System.currentTimeMillis()-start)); assertArrayEquals(parallel, serial); } } I run that a few times on my laptop with 2 cores and the results were around this: 1 2 Merge Sort done in: 31077 Parallel Merge Sort done in: 20020 Clearly Parallel Merge Sort is much faster for arrays of 100M of elements. The speedup is not 2x, because there are overheads for scheduling tasks in pool, but still the difference is substantial. Both sorting algorithms use Insertion Sort when subarray to sort is below defined threshold. I found value 128 to give pretty good results in my environment - maybe there is a better value around, but, in my case, it gave better results than values 64, 256, 512, 768, 1024, etc. References See details of Insertion Sort See detailed explanation of Merge Sort ForkJoin explained Check out other algorithms in Algorithms section" /><link rel="canonical" href="https://farenda.com/parallel-merge-sort-in-java/" /><meta property="og:url" content="https://farenda.com/parallel-merge-sort-in-java/" /><meta property="og:site_name" content="Farenda" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2017-03-30T19:40:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Parallel Merge Sort in Java" /><meta name="twitter:site" content="@rudaliszka" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-06-08T18:35:03+02:00","datePublished":"2017-03-30T19:40:00+02:00","description":"Divide and Conquer algorithms are great subject for parallelism. Here we present Parallel Merge Sort implemented using Java ForkJoin Framework. Parallel sort steps Parallel Merge Sort consists of the same steps as other tasks executed in ForkJoin Pool, namely: If the task is small enough - do it directly. In case of Merge Sort we can decide that when a subarray to sort is smaller than some value (we name it SORT_THRESHOLD), then we’ll use Insertion Sort, which will sort it in-place. Else do Merge Sort of both parts as separate tasks, executed in a ForkJoin Pool. This will allow us to sort parts of an array independently and then just merge them. MergSort as RecursiveAction The implementation consists of a few key points we need to do: extend RecursiveAction to allow execution in ForkJoin Pool decide when to sort directly execute parallel tasks for subarrays merge everything at the end. Therefore the heart of the Parallel Merge Sort with Fork Join Framework looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import java.util.concurrent.RecursiveAction; public class ParallelMergeSort extends RecursiveAction { // Decides when to fork or compute directly: private static final int SORT_THRESHOLD = 128; // Defines subarray to sort: public ParallelMergeSort(int[] values, int from, int to) @Override protected void compute() { if (from &lt; to) { int size = to - from; if (size &lt; SORT_THRESHOLD) { // Sort in-place using Insertion Sort: insertionSort(); } else { int mid = from + Math.floorDiv(size, 2); // Do MergeSort in parallel on subarrays. // This will submit the tasks to the current // ForkJoin Pool: invokeAll( new ParallelMergeSort(values, from, mid), new ParallelMergeSort(values, mid + 1, to)); // Merge sorted subarrays: merge(mid); } } } // ... } Complete Parallel Merge Sorter This is complete implementation of Parallel Merge Sort using Fork-Join Framework to do parallel execution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 import java.util.Arrays; import java.util.concurrent.RecursiveAction; public class ParallelMergeSort extends RecursiveAction { // Decides when to fork or compute directly: private static final int SORT_THRESHOLD = 128; private final int[] values; private final int from; private final int to; public ParallelMergeSort(int[] values) { this(values, 0, values.length-1); } public ParallelMergeSort(int[] values, int from, int to) { this.values = values; this.from = from; this.to = to; } public void sort() { compute(); } @Override protected void compute() { if (from &lt; to) { int size = to - from; if (size &lt; SORT_THRESHOLD) { insertionSort(); } else { int mid = from + Math.floorDiv(size, 2); invokeAll( new ParallelMergeSort(values, from, mid), new ParallelMergeSort(values, mid + 1, to)); merge(mid); } } } private void insertionSort() { for (int i = from+1; i &lt;= to; ++i) { int current = values[i]; int j = i-1; while (from &lt;= j &amp;&amp; current &lt; values[j]) { values[j+1] = values[j--]; } values[j+1] = current; } } private void merge(int mid) { int[] left = Arrays.copyOfRange(values, from, mid+1); int[] right = Arrays.copyOfRange(values, mid+1, to+1); int f = from; int li = 0, ri = 0; while (li &lt; left.length &amp;&amp; ri &lt; right.length) { if (left[li] &lt;= right[ri]) { values[f++] = left[li++]; } else { values[f++] = right[ri++]; } } while (li &lt; left.length) { values[f++] = left[li++]; } while (ri &lt; right.length) { values[f++] = right[ri++]; } } } Test and performance comparison As usually we need to check somehow that it works. :wink: But for brevity we’ll show only JUnit test for substantial amount of data (100 millions) and we’ll do that for both Merge Sort and Parallel Merge Sort: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import org.junit.Test; import java.util.Arrays; import java.util.Random; import static org.junit.Assert.assertArrayEquals; public class ParallelMergeSortTest { //... other tests cut for brevity @Test public void performanceTest() { int[] serial = new Random().ints(100_000_000).toArray(); int[] parallel = Arrays.copyOf(serial, serial.length); MergeSort mergeSort = new MergeSort(); long start = System.currentTimeMillis(); mergeSort.sort(serial); System.out.println(&quot;Merge Sort done in: &quot; + (System.currentTimeMillis()-start)); ParallelMergeSort sorter = new ParallelMergeSort(parallel); start = System.currentTimeMillis(); sorter.sort(); System.out.println(&quot;Parallel Merge Sort done in: &quot; + (System.currentTimeMillis()-start)); assertArrayEquals(parallel, serial); } } I run that a few times on my laptop with 2 cores and the results were around this: 1 2 Merge Sort done in: 31077 Parallel Merge Sort done in: 20020 Clearly Parallel Merge Sort is much faster for arrays of 100M of elements. The speedup is not 2x, because there are overheads for scheduling tasks in pool, but still the difference is substantial. Both sorting algorithms use Insertion Sort when subarray to sort is below defined threshold. I found value 128 to give pretty good results in my environment - maybe there is a better value around, but, in my case, it gave better results than values 64, 256, 512, 768, 1024, etc. References See details of Insertion Sort See detailed explanation of Merge Sort ForkJoin explained Check out other algorithms in Algorithms section","headline":"Parallel Merge Sort in Java","mainEntityOfPage":{"@type":"WebPage","@id":"https://farenda.com/parallel-merge-sort-in-java/"},"url":"https://farenda.com/parallel-merge-sort-in-java/"}</script><title>Parallel Merge Sort in Java | Farenda</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Farenda"><meta name="application-name" content="Farenda"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end">
<div class="profile-wrapper text-center">
<div id="avatar"> <a href="/" class="mx-auto"> </a>
</div>
<div class="site-title"> <a href="/">Farenda</a>
</div>
<div class="site-subtitle font-italic">Programming bits from the past</div>
</div>
<ul class="w-100">
<li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a>
</li>
<li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a>
</li>
<li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a>
</li>
<li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a>
</li>
</ul>
<div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/pwojnowski" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/rudaliszka" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="https://www.linkedin.com/in/przemys%C5%82aw-wojnowski-b2b5462/" aria-label="linkedin" target="_blank" rel="noopener noreferrer"> <i class="fab fa-linkedin"></i> </a> <a href="javascript:location.href%20=%20'mailto:'%20+%20['hello%20farenda.com',''].join('@')" aria-label="email"> <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss"> <i class="fas fa-rss"></i> </a>
</div>
</div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Parallel Merge Sort in Java</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div>
<i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel">Cancel</span>
</div></div><div id="main-wrapper" class="d-flex justify-content-center">
<div id="main" class="container pl-xl-4 pr-xl-4">
<div class="row">
<div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2">
<h1 data-toc-skip>Parallel Merge Sort in Java</h1>
<div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1490895600" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Mar 30, 2017 </em> </span> <span> Updated <em class="" data-ts="1686242103" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Jun 8, 2023 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://twitter.com/rudaliszka">Przemysław Wojnowski</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="916 words"> <em>5 min</em> read</span>
</div>
</div>
</div>
<div class="post-content">
<p><em>Divide and Conquer</em> algorithms are great subject for <strong>parallelism</strong>. Here we present <strong>Parallel Merge Sort</strong> implemented using <em>Java ForkJoin Framework</em>.</p>
<h1 id="parallel-sort-steps">Parallel sort steps</h1>
<p>Parallel Merge Sort consists of the same steps as other tasks executed in <a href="https://farenda.com/java/java-fork-join-example">ForkJoin Pool</a>, namely:</p>
<ol>
<li>If the task is small enough - do it directly. In case of <a href="https://farenda.com/algorithms/merge-sort-in-java">Merge Sort</a> we can decide that when a subarray to sort is smaller than some value (we name it <code class="language-plaintext highlighter-rouge">SORT_THRESHOLD</code>), then we’ll use <a href="https://farenda.com/algorithms/insertion-sort-in-java">Insertion Sort</a>, which will sort it in-place.</li>
<li>Else do Merge Sort of both parts as separate tasks, executed in a <strong>ForkJoin Pool</strong>. This will allow us to sort parts of an array independently and then just merge them.</li>
</ol>
<h1 id="mergsort-as-recursiveaction">MergSort as RecursiveAction</h1>
<p>The implementation consists of a few key points we need to do:</p>
<ul>
<li>extend <code class="language-plaintext highlighter-rouge">RecursiveAction</code> to allow execution in ForkJoin Pool</li>
<li>decide when to sort directly</li>
<li>execute parallel tasks for subarrays</li>
<li>merge everything at the end.</li>
</ul>
<p>Therefore the heart of the Parallel Merge Sort with Fork Join Framework looks like this:</p>
<div class="language-java highlighter-rouge">
<div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button>
</div>
<div class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td>
<td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.concurrent.RecursiveAction</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ParallelMergeSort</span> <span class="kd">extends</span> <span class="nc">RecursiveAction</span> <span class="o">{</span>

    <span class="c1">// Decides when to fork or compute directly:</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">SORT_THRESHOLD</span> <span class="o">=</span> <span class="mi">128</span><span class="o">;</span>

    <span class="c1">// Defines subarray to sort:</span>
    <span class="kd">public</span> <span class="nf">ParallelMergeSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">values</span><span class="o">,</span> <span class="kt">int</span> <span class="n">from</span><span class="o">,</span> <span class="kt">int</span> <span class="n">to</span><span class="o">)</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">compute</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">from</span> <span class="o">&lt;</span> <span class="n">to</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">to</span> <span class="o">-</span> <span class="n">from</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="no">SORT_THRESHOLD</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Sort in-place using Insertion Sort:</span>
                <span class="n">insertionSort</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">from</span> <span class="o">+</span> <span class="nc">Math</span><span class="o">.</span><span class="na">floorDiv</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
                <span class="c1">// Do MergeSort in parallel on subarrays.</span>
                <span class="c1">// This will submit the tasks to the current</span>
                <span class="c1">// ForkJoin Pool:</span>
                <span class="n">invokeAll</span><span class="o">(</span>
                        <span class="k">new</span> <span class="nf">ParallelMergeSort</span><span class="o">(</span><span class="n">values</span><span class="o">,</span> <span class="n">from</span><span class="o">,</span> <span class="n">mid</span><span class="o">),</span>
                        <span class="k">new</span> <span class="nf">ParallelMergeSort</span><span class="o">(</span><span class="n">values</span><span class="o">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">to</span><span class="o">));</span>
                <span class="c1">// Merge sorted subarrays:</span>
                <span class="n">merge</span><span class="o">(</span><span class="n">mid</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</pre></td>
</tr></tbody></table></code></div>
</div>
<h1 id="complete-parallel-merge-sorter">Complete Parallel Merge Sorter</h1>
<p>This is complete implementation of Parallel Merge Sort using <strong>Fork-Join Framework</strong> to do parallel execution:</p>
<div class="language-java highlighter-rouge">
<div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button>
</div>
<div class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
</pre></td>
<td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.RecursiveAction</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ParallelMergeSort</span> <span class="kd">extends</span> <span class="nc">RecursiveAction</span> <span class="o">{</span>

    <span class="c1">// Decides when to fork or compute directly:</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">SORT_THRESHOLD</span> <span class="o">=</span> <span class="mi">128</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">values</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">from</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">to</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">ParallelMergeSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">values</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">(</span><span class="n">values</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">values</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">ParallelMergeSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">values</span><span class="o">,</span> <span class="kt">int</span> <span class="n">from</span><span class="o">,</span> <span class="kt">int</span> <span class="n">to</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">from</span> <span class="o">=</span> <span class="n">from</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">to</span> <span class="o">=</span> <span class="n">to</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">compute</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">compute</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">from</span> <span class="o">&lt;</span> <span class="n">to</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">to</span> <span class="o">-</span> <span class="n">from</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="no">SORT_THRESHOLD</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">insertionSort</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">from</span> <span class="o">+</span> <span class="nc">Math</span><span class="o">.</span><span class="na">floorDiv</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
                <span class="n">invokeAll</span><span class="o">(</span>
                        <span class="k">new</span> <span class="nf">ParallelMergeSort</span><span class="o">(</span><span class="n">values</span><span class="o">,</span> <span class="n">from</span><span class="o">,</span> <span class="n">mid</span><span class="o">),</span>
                        <span class="k">new</span> <span class="nf">ParallelMergeSort</span><span class="o">(</span><span class="n">values</span><span class="o">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">to</span><span class="o">));</span>
                <span class="n">merge</span><span class="o">(</span><span class="n">mid</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">insertionSort</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">from</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">to</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">current</span> <span class="o">=</span> <span class="n">values</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">from</span> <span class="o">&lt;=</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">current</span> <span class="o">&lt;</span> <span class="n">values</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">values</span><span class="o">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">values</span><span class="o">[</span><span class="n">j</span><span class="o">--];</span>
            <span class="o">}</span>
            <span class="n">values</span><span class="o">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">current</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">merge</span><span class="o">(</span><span class="kt">int</span> <span class="n">mid</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">left</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOfRange</span><span class="o">(</span><span class="n">values</span><span class="o">,</span> <span class="n">from</span><span class="o">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">right</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOfRange</span><span class="o">(</span><span class="n">values</span><span class="o">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">to</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">f</span> <span class="o">=</span> <span class="n">from</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">li</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">ri</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">li</span> <span class="o">&lt;</span> <span class="n">left</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">ri</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">left</span><span class="o">[</span><span class="n">li</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="o">[</span><span class="n">ri</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">values</span><span class="o">[</span><span class="n">f</span><span class="o">++]</span> <span class="o">=</span> <span class="n">left</span><span class="o">[</span><span class="n">li</span><span class="o">++];</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">values</span><span class="o">[</span><span class="n">f</span><span class="o">++]</span> <span class="o">=</span> <span class="n">right</span><span class="o">[</span><span class="n">ri</span><span class="o">++];</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">li</span> <span class="o">&lt;</span> <span class="n">left</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">values</span><span class="o">[</span><span class="n">f</span><span class="o">++]</span> <span class="o">=</span> <span class="n">left</span><span class="o">[</span><span class="n">li</span><span class="o">++];</span>
        <span class="o">}</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">ri</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">values</span><span class="o">[</span><span class="n">f</span><span class="o">++]</span> <span class="o">=</span> <span class="n">right</span><span class="o">[</span><span class="n">ri</span><span class="o">++];</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td>
</tr></tbody></table></code></div>
</div>
<h1 id="test-and-performance-comparison">Test and performance comparison</h1>
<p>As usually we need to check somehow that it works. <img class="emoji" title=":wink:" alt=":wink:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f609.png" height="20" width="20"> But for brevity we’ll show only <a href="https://farenda.com/junit-tutorial">JUnit</a> test for substantial amount of data (100 millions) and we’ll do that for both <a href="https://farenda.com/algorithms/merge-sort-in-java">Merge Sort</a> and Parallel Merge Sort:</p>
<div class="language-java highlighter-rouge">
<div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button>
</div>
<div class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td>
<td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">org.junit.Test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Random</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">junit</span><span class="o">.</span><span class="na">Assert</span><span class="o">.</span><span class="na">assertArrayEquals</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ParallelMergeSortTest</span> <span class="o">{</span>

    <span class="c1">//... other tests cut for brevity</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">performanceTest</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">serial</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">().</span><span class="na">ints</span><span class="o">(</span><span class="mi">100_000_000</span><span class="o">).</span><span class="na">toArray</span><span class="o">();</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">parallel</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">serial</span><span class="o">,</span> <span class="n">serial</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>

        <span class="nc">MergeSort</span> <span class="n">mergeSort</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MergeSort</span><span class="o">();</span>
        <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
        <span class="n">mergeSort</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">serial</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Merge Sort done in: "</span>
                <span class="o">+</span> <span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()-</span><span class="n">start</span><span class="o">));</span>

        <span class="nc">ParallelMergeSort</span> <span class="n">sorter</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ParallelMergeSort</span><span class="o">(</span><span class="n">parallel</span><span class="o">);</span>
        <span class="n">start</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
        <span class="n">sorter</span><span class="o">.</span><span class="na">sort</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Parallel Merge Sort done in: "</span>
                <span class="o">+</span> <span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()-</span><span class="n">start</span><span class="o">));</span>

        <span class="n">assertArrayEquals</span><span class="o">(</span><span class="n">parallel</span><span class="o">,</span> <span class="n">serial</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td>
</tr></tbody></table></code></div>
</div>
<p>I run that a few times on my laptop with 2 cores and the results were around this:</p>
<div class="language-plaintext highlighter-rouge">
<div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button>
</div>
<div class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td>
<td class="rouge-code"><pre>Merge Sort done in: 31077
Parallel Merge Sort done in: 20020
</pre></td>
</tr></tbody></table></code></div>
</div>
<p>Clearly Parallel Merge Sort is much faster for arrays of 100M of elements. The speedup is not 2x, because there are overheads for scheduling tasks in pool, but still the difference is substantial.</p>
<p>Both sorting algorithms use <a href="https://farenda.com/algorithms/insertion-sort-in-java">Insertion Sort</a> when subarray to sort is below defined threshold. I found value <strong>128</strong> to give pretty good results in my environment - maybe there is a better value around, but, in my case, it gave better results than values 64, 256, 512, 768, 1024, etc.</p>
<h1 id="references">References</h1>
<ul>
<li>See details of <a href="https://farenda.com/algorithms/insertion-sort-in-java">Insertion Sort</a>
</li>
<li>See detailed explanation of <a href="https://farenda.com/algorithms/merge-sort-in-java">Merge Sort</a>
</li>
<li><a href="https://farenda.com/java/java-fork-join-example">ForkJoin explained</a></li>
<li>Check out other algorithms in <a href="https://farenda.com/tags/algorithms">Algorithms section</a>
</li>
</ul>
</div>
<div class="post-tail-wrapper text-muted">
<div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/algorithms/" class="post-tag no-text-decoration">algorithms</a> <a href="/tags/java/" class="post-tag no-text-decoration">java</a>
</div>
<div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2">
<div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div>
<div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Parallel%20Merge%20Sort%20in%20Java%20-%20Farenda&amp;url=https%3A%2F%2Ffarenda.com%2Fparallel-merge-sort-in-java%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Parallel%20Merge%20Sort%20in%20Java%20-%20Farenda&amp;u=https%3A%2F%2Ffarenda.com%2Fparallel-merge-sort-in-java%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Ffarenda.com%2Fparallel-merge-sort-in-java%2F&amp;text=Parallel%20Merge%20Sort%20in%20Java%20-%20Farenda" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Ffarenda.com%2Fparallel-merge-sort-in-java%2F" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span>
</div>
</div>
</div>
</div></div>
<div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access">
<div id="access-lastmod" class="post">
<div class="panel-heading">Recently Updated</div>
<ul class="post-content pl-0 pb-1 ml-1 mt-2">
<li><a href="/merge-sort-in-java/">Merge Sort in Java</a></li>
<li><a href="/clojure-repl-docs/">Clojure REPL docs</a></li>
<li><a href="/composed-method-pattern/">Composed Method Pattern explained</a></li>
<li><a href="/quicksort-in-java/">Quicksort in Java</a></li>
<li><a href="/insertion-sort-in-clojure/">Insertion Sort in Clojure</a></li>
</ul>
</div>
<div id="access-tags">
<div class="panel-heading">Trending Tags</div>
<div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/clojure/">clojure</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/security/">security</a> <a class="post-tag" href="/tags/software-design/">software-design</a>
</div>
</div>
</div></div>
</div>
<div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5">
<div id="related-posts" class="mb-2 mb-sm-4">
<h3 class="pt-2 mb-4 ml-1" data-toc-skip>Further Reading</h3>
<div class="card-deck mb-4">
<div class="card"> <a href="/merge-sort-in-java/"><div class="card-body"> <em class="small" data-ts="1478866200" data-df="ll"> Nov 11, 2016 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Merge Sort in Java</h3>
<div class="text-muted small"><p> In this post we’ll implement Merge Sort in Java. It’s fast, divide and conquer, sorting algorithm that can be also parallelized. How Merge Sort works The algorithm belongs to the Divide and Con...</p></div>
</div></a>
</div>
<div class="card"> <a href="/quicksort-in-java/"><div class="card-body"> <em class="small" data-ts="1481884800" data-df="ll"> Dec 16, 2016 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Quicksort in Java</h3>
<div class="text-muted small"><p> Quicksort is one of the fastest sorting algorithms. In this article we implement Quicksort in Java, describe how it works and its properties. How Quicksort works Similarly to the merge sort, qu...</p></div>
</div></a>
</div>
<div class="card"> <a href="/binary-search-algorithm-in-java/"><div class="card-body"> <em class="small" data-ts="1468818060" data-df="ll"> Jul 18, 2016 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Binary Search algorithm in Java</h3>
<div class="text-muted small"><p> Binary Search is the fastest algorithm for finding an element in a sorted list. Also it’s easy to implement and very useful. Let’s see how it works and implement! How it works The procedure is ...</p></div>
</div></a>
</div>
</div>
</div>
<div class="post-navigation d-flex justify-content-between"> <a href="/clojure-transients-fast-mutations-in-persistent-world/" class="btn btn-outline-primary" prompt="Older"><p>Clojure transients - fast mutations in persistent world</p></a> <a href="/calculating-md5/" class="btn btn-outline-primary" prompt="Newer"><p>Calculating MD5 hash</p></a>
</div>
</div></div>
</div>
<div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content">
<div id="search-hints"><div id="access-tags">
<div class="panel-heading">Trending Tags</div>
<div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/clojure/">clojure</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/security/">security</a> <a class="post-tag" href="/tags/software-design/">software-design</a>
</div>
</div></div>
<div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div>
</div></div>
</div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3">
<div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/rudaliszka">Przemysław Wojnowski</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div>
<div class="footer-right"><p class="mb-0">Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div>
</div></div></footer><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false">
<div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">×</span> </button>
</div>
<div class="toast-body text-center pt-0">
<p class="pl-2 pr-2 mb-3">A new version of content is available.</p>
<button type="button" class="btn btn-primary" aria-label="Update"> Update </button>
</div>
</div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-7Y9PYV966D"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-7Y9PYV966D'); }); </script>
