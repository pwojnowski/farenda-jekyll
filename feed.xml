<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://farenda.com/</id><title>Farenda</title><subtitle>Yet another programming blog. Articles around Java, Clojure, Python, and other things around IT.</subtitle> <updated>2024-11-01T19:14:48+01:00</updated> <author> <name>Przemysław Wojnowski</name> <uri>https://farenda.com/</uri> </author><link rel="self" type="application/atom+xml" href="https://farenda.com/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://farenda.com/"/> <generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator> <rights> © 2024 Przemysław Wojnowski </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Caesar cipher in Java</title><link href="https://farenda.com/caesar-cipher-in-java/" rel="alternate" type="text/html" title="Caesar cipher in Java" /><published>2017-07-21T22:00:00+02:00</published> <updated>2023-06-08T18:35:03+02:00</updated> <id>https://farenda.com/caesar-cipher-in-java/</id> <content src="https://farenda.com/caesar-cipher-in-java/" /> <author> <name>Przemysław Wojnowski</name> </author> <summary> One of the simplest cryptographic algorithms is Caesar cipher. Although it is not secure at all, it shows how basic synchronous ciphers work. Intro The cipher method is named after Julius Caesar, who presumably have used it to encrypt his military messages (see the history section at Wikipedia). Maybe at that time it was the state of the art. Anyway, the algorithm is good to know in case yo... </summary> </entry> <entry><title>Fisher-Yates Shuffle Algorithm</title><link href="https://farenda.com/fisher-yates-shuffle-algorithm/" rel="alternate" type="text/html" title="Fisher-Yates Shuffle Algorithm" /><published>2017-04-22T18:16:00+02:00</published> <updated>2017-04-22T18:16:00+02:00</updated> <id>https://farenda.com/fisher-yates-shuffle-algorithm/</id> <content src="https://farenda.com/fisher-yates-shuffle-algorithm/" /> <author> <name>Przemysław Wojnowski</name> </author> <summary> Shuffling of collection of items sounds like a trivial task, but in reality there are subtle traps. In this post we’re going to learn how to shuffle things using unbiased Fisher-Yates Shuffle Algorithm and how to do that in different languages. Shuffling traps There are some things to be aware when implementing/choosing a shuffling algorithm: Use good Pseudo-Random Number Generator, one... </summary> </entry> <entry><title>Calculating MD5 hash</title><link href="https://farenda.com/calculating-md5/" rel="alternate" type="text/html" title="Calculating MD5 hash" /><published>2017-04-21T12:30:00+02:00</published> <updated>2023-06-08T18:35:03+02:00</updated> <id>https://farenda.com/calculating-md5/</id> <content src="https://farenda.com/calculating-md5/" /> <author> <name>Przemysław Wojnowski</name> </author> <summary> MD5 is a popular cryptographic algorithm used for sign messages, as checksum, and various other cases. In this post we’re going to show a few approaches to calculate it, especially in JVM land. MD5 (Message Digest 5) algorithm should not be used for serious cryptography, because it’s insecure and can be broken very fast using even commodity hardware. Nevertheless, you may encounter it in var... </summary> </entry> <entry><title>Parallel Merge Sort in Java</title><link href="https://farenda.com/parallel-merge-sort-in-java/" rel="alternate" type="text/html" title="Parallel Merge Sort in Java" /><published>2017-03-30T19:40:00+02:00</published> <updated>2023-06-08T18:35:03+02:00</updated> <id>https://farenda.com/parallel-merge-sort-in-java/</id> <content src="https://farenda.com/parallel-merge-sort-in-java/" /> <author> <name>Przemysław Wojnowski</name> </author> <summary> Divide and Conquer algorithms are great subject for parallelism. Here we present Parallel Merge Sort implemented using Java ForkJoin Framework. Parallel sort steps Parallel Merge Sort consists of the same steps as other tasks executed in ForkJoin Pool, namely: If the task is small enough - do it directly. In case of Merge Sort we can decide that when a subarray to sort is smaller than so... </summary> </entry> <entry><title>Clojure transients - fast mutations in persistent world</title><link href="https://farenda.com/clojure-transients-fast-mutations-in-persistent-world/" rel="alternate" type="text/html" title="Clojure transients - fast mutations in persistent world" /><published>2016-12-21T06:01:00+01:00</published> <updated>2023-06-08T18:35:03+02:00</updated> <id>https://farenda.com/clojure-transients-fast-mutations-in-persistent-world/</id> <content src="https://farenda.com/clojure-transients-fast-mutations-in-persistent-world/" /> <author> <name>Przemysław Wojnowski</name> </author> <summary> Clojure transients is a nice way to optimize performance of sensitive code without leaving familiar Clojure world. In this post we show how to use them to boost performance. Basic flow with transients The code structure is the same as in any Clojure code, except turning mutations on using transient function, modifications using bang! versions of functions, and persisting back with persiste... </summary> </entry> </feed>
